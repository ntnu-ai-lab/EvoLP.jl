var documenterSearchIndex = {"docs":
[{"location":"man/islands.html#Island-Models-using-MPI","page":"Island Models","title":"Island Models using MPI","text":"","category":"section"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"note: Note\nThis is a somewhat advanced topic. If you are new to parallel computing, we recommend reading the page on Parallelism first.","category":"page"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"EvoLP has newly implemented support for island models of evolutionary algorithms as an extension. The extension, EvoLPIslands, is implemented using the weak dependency feature added to Julia in v1.9.","category":"page"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"details: Loading the extension\nEvoLPIslands will be activated if and only if you have both EvoLP and MPI loaded into your current scope via the using or import keywords.","category":"page"},{"location":"man/islands.html#About-Island-Models","page":"Island Models","title":"About Island Models","text":"","category":"section"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"In an island model, multiple populations (or islands) evolve concurrently, and a subpopulation (or deme) occasionally drifts from one island to another in a process called migration. Migration passively helps with diversity preservation, which in turn benefits the exploration of large search spaces.","category":"page"},{"location":"man/islands.html#Migration","page":"Island Models","title":"Migration","text":"","category":"section"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"The migration process is broken down in three steps: drift, strand and reinsert!:","category":"page"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"(Image: The three operators of EvoLP: drift, strand and reinsert.)","category":"page"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"To implement these operators, EvoLP uses MPI.jl, a wrapper of MPI for Julia. MPI is a communication standard available in many parallel computing architectures, most notably High Performance Computing clusters, but it can also be used in your local machine.","category":"page"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"Specifically, EvoLP uses the Send and Receive MPI directives, which are blocking. However, there is no need to use these directly. Instead, using the drift, strand, and reinsert! operators in your algorithms should suffice.","category":"page"},{"location":"man/islands.html#EvoLP.drift","page":"Island Models","title":"EvoLP.drift","text":"drift(S_M::DemeSelector, population, y, dest; comm=MPI.COMM_WORLD)\n\nSelect and send individuals from population to the dest island, according to the deme selector S_M and considering their fitnesses y.\n\nReturns a 2-tuple containing the sent deme, and its MPI_Request.\n\n\n\n\n\n","category":"function"},{"location":"man/islands.html#EvoLP.strand","page":"Island Models","title":"EvoLP.strand","text":"strand(S_M::DemeSelector, d, src; comm=MPI.COMM_WORLD)\n\nReceive d-dimensional individuals from src. The deme selector S_M is used to decode the received information.\n\nReturns a 2-tuple containing the received deme, and its MPI_Request.\n\n\n\n\n\n","category":"function"},{"location":"man/islands.html#EvoLP.reinsert!","page":"Island Models","title":"EvoLP.reinsert!","text":"reinsert!(population, y, R_M::DemeSelector, M)\n\n(Re)insert a deme M into the population, according to reinsertion criterion provided by the R_M deme selector, and the population's fitnesses y.\n\nThe new individuals will be appended into population.\n\nReturns the indices of the deme that must be deleted.\n\n\n\n\n\n","category":"function"},{"location":"man/islands.html#Selecting-a-Deme","page":"Island Models","title":"Selecting a Deme","text":"","category":"section"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"To send, receive, and reinsert a deme, we introduced DemeSelectors that allow for two different types of selection: random, and worst.","category":"page"},{"location":"man/islands.html#EvoLP.RandomDemeSelector","page":"Island Models","title":"EvoLP.RandomDemeSelector","text":"Deme selector for obtaining a random sample of size k\n\n\n\n\n\n","category":"type"},{"location":"man/islands.html#EvoLP.WorstDemeSelector","page":"Island Models","title":"EvoLP.WorstDemeSelector","text":"Deme selector for obtaining the worst k individuals\n\n\n\n\n\n","category":"type"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"As with other operators in EvoLP, the deme selectors can be passed to the select method—both for selecting the deme that will migrate as well as selecting the deme that will be replaced.","category":"page"},{"location":"man/islands.html#EvoLP.select-Tuple{RandomDemeSelector, Any}","page":"Island Models","title":"EvoLP.select","text":"select(S_M::RandomDemeSelector, y)\n\nReturn a list of size S_M.k of random indices from a vector of fitnesses y. Used inside drift to select individuals to be sent to another island, or inside reinsert! to select individuals to be replaced.\n\n\n\n\n\n","category":"method"},{"location":"man/islands.html#EvoLP.select-Tuple{WorstDemeSelector, Any}","page":"Island Models","title":"EvoLP.select","text":"select(S_M::WorstDemeSelector, y)\n\nReturn the indices of the S_M.k-worst fitnesses in y. Used inside drift to select individuals to be sent to another island, or inside reinsert! to select individuals to be replaced.\n\n\n\n\n\n","category":"method"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"We also provide a built-in toy algorithm, the island GA:","category":"page"},{"location":"man/islands.html#EvoLP.islandGA!","page":"Island Models","title":"EvoLP.islandGA!","text":"function islandGA!(\n    logbook::Logbook,\n    f::Function,\n    population::AbstractVector,\n    max_it::Integer,\n    S_P::EvoLP.Selector,\n    X::EvoLP.Recombinator,\n    Mut::EvoLP.Mutator,\n    μ::Integer,\n    S_M::DemeSelector,\n    R_M::DemeSelector,\n    dest::Integer,\n    src::Integer,\n    comm::MPI.COMM_WORLD)\n\nGenerational genetic algorithm with islands.\n\nArguments\n\nlogbook::Logbook: to save Statistics\nf::Function: objective function to minimise\npopulation::AbstractVector: a list of vector individuals\nmax_it::Integer: number of iterations\nS_P::ParentSelector: one of the available EvoLP.Selector\nX::Recombinator: one of the available EvoLP.Recombinator\nMut::Mutator: one of the available EvoLP.Mutator\nμ::Integer: migration rate (in number of iterations)\nS_M::DemeSelector: selection policy. One of the available EvoLP.DemeSelector\nR_M::DemeSelector: replacement policy. One of the available EvoLP.DemeSelector\ndest::Integer: ID of destination island\nsrc::Integer: ID of source island\ncomm::MPI.Comm: an MPI communicator. Usually MPI.COMM_WORLD.\n\n\n\n\n\n","category":"function"},{"location":"man/islands.html#Further-Reading","page":"Island Models","title":"Further Reading","text":"","category":"section"},{"location":"man/islands.html","page":"Island Models","title":"Island Models","text":"Our paper Evolutionary Computation with Islands: Extending EvoLP.jl for Parallel Computing.\nEvoLP's Parallel documentation page.\nThe MPI.jl documentation.","category":"page"},{"location":"references.html#References-and-related-links","page":"References & related links","title":"References and related links","text":"","category":"section"},{"location":"references.html","page":"References & related links","title":"References & related links","text":"EvoLP is heavily inspired by other packages and scientific works.","category":"page"},{"location":"references.html#Related-Packages","page":"References & related links","title":"Related Packages","text":"","category":"section"},{"location":"references.html#Julia","page":"References & related links","title":"Julia","text":"","category":"section"},{"location":"references.html","page":"References & related links","title":"References & related links","text":"Metaheuristics is a package with metaheuristic solvers of all kinds.\nEvolutionary contains multiple GAs and EAs implementations.\nGeneticAlgorithms is a somewhat outdated package for writing GAs.\nBlackBoxOptim is another blackbox optimisation package.\nJuMP is focused on mathematical optimisation for differentiable objective functions.","category":"page"},{"location":"references.html#Python","page":"References & related links","title":"Python","text":"","category":"section"},{"location":"references.html","page":"References & related links","title":"References & related links","text":"DEAP is a somewhat outdated evolutionary playground for Python 2.\nPygmo is a fully-fledged optimisation suite from the European Space Agency.","category":"page"},{"location":"references.html#References","page":"References & related links","title":"References","text":"","category":"section"},{"location":"references.html","page":"References & related links","title":"References & related links","text":"[1] Eiben, A.E. and Smith, J.E. 2015. Introduction to Evolutionary Computing. Springer.\n[2] Kochenderfer, M.J. and Wheeler, T.A. 2019. Algorithms for optimization. Mit Press.\n[3] Simon, D. 2013. Evolutionary Optimization Algorithms. John Wiley & Sons.\n[4] Surjanovic, S. & Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets.","category":"page"},{"location":"tuto/oneplusone_onemax.html#11-EA-for-maximising-a-pseudoboolean-function","page":"The OneMax problem","title":"1+1 EA for maximising a pseudoboolean function","text":"","category":"section"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"This tutorial showcases how to use the built-in 1+1 Evolutionary Algorithm (EA).","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"First, we import our modules like so:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"using EvoLP\nusing OrderedCollections\nusing Statistics","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"For this example, we will use the onemax test function, which is already included in EvoLP:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"@doc onemax","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"The OneMax function returns the sum of the individual. For an individual of length n, maximum is achieved with n ones.textOneMax(mathbfx) = sum_i=1^n x_i","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"In an EA we use vectors as individuals. The 1+1 EA features 1 parent and 1 offspring each iteration.","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"Let's start creating the first individual. We can generate it manually, or use a generator. Let's do the latter:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"@doc binary_vector_pop","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"binary_vector_pop(n, l; rng=Random.GLOBAL_RNG)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"Generate a population of n vector binary individuals, each of length l.","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"It is important to note that the return value of the binary_vector_pop generator is a  population:  a list. This means we only want the first (and only) element inside:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"ind_size = 15\nfirstborn = binary_vector_pop(1, ind_size)[1]","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"15-element BitVector:\n    0\n    0\n    1\n    1\n    0\n    0\n    1\n    0\n    0\n    1\n    1\n    0\n    1\n    0\n    1","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"Since the 1+1 EA works on a single individual, we only have the mutation step. We can set up the appropriate mutation operator: BitwiseMutator.","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"@doc BitwiseMutator","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"Bitwise mutation with probability λ of flipping each bit.","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"This mutation operator needs a probability lambda for flipping each bit, so we pass it like so:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"Mut = BitwiseMutator(1/ind_size)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"BitwiseMutator(0.06666666666666667)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"Now on to the fitness function. Since EvoLP is built for minimisation, in order to do maximisation we need to optimise for the negative of OneMax:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"f(x) = -onemax(x)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"f (generic function with 1 method)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"Let's use the Logbook to record the fitness value on each iteration. We can do so by the Base.identity function as it will return the same value as the fitness:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"statnames = [\"fit\"]\ncallables = [identity]\nthedict = LittleDict(statnames, callables)\nlogbook = Logbook(thedict)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"Logbook(LittleDict{AbstractString, Function, Vector{AbstractString}, Vector{Function}}(\"fit\" => identity), NamedTuple{(:fit,)}[])","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"We are now ready to use the oneplusone built-in algorithm:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"@doc oneplusone","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"oneplusone(f::Function, ind, k_max, M)\noneplusone(logger::Logbook, f::Function, ind, k_max, M)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"1+1 EA algorithm.Argumentsf: Objective function to minimise\nind: Individual to start the evolution\nk_max: Maximum number of iterations\nM::Mutator: A mutation method. See mutation.Returns a Result.","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"result = oneplusone(logbook, f, firstborn, 50, Mut);","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"The output was suppressed so that we can analyse each part of the result separately using the Result functions:","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"@show optimum(result)\n@show optimizer(result)\n@show iterations(result)\n@show f_calls(result)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"optimum(result) = -15\noptimizer(result) = Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\niterations(result) = 50\nf_calls(result) = 102","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"We can also take a look at the logbook records and see how the statistics changed throughout the run (although in this case we just logged the fitness):","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"first(logbook.records, 20)","category":"page"},{"location":"tuto/oneplusone_onemax.html","page":"The OneMax problem","title":"The OneMax problem","text":"20-element Vector{NamedTuple{(:fit,)}}:\n    (fit = [-7],)\n    (fit = [-7],)\n    (fit = [-8],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-9],)\n    (fit = [-10],)\n    (fit = [-10],)\n    (fit = [-10],)\n    (fit = [-10],)\n    (fit = [-11],)\n    (fit = [-11],)\n    (fit = [-11],)","category":"page"},{"location":"man/mutation.html#Mutation-operators","page":"Mutation operators","title":"Mutation operators","text":"","category":"section"},{"location":"man/mutation.html","page":"Mutation operators","title":"Mutation operators","text":"Mutation operators (a.k.a. mutators) work on a single individual and return a copy. Some of them have parameters to control how the mutation is performed, and are dependent on both the data contained in an individual and its representation.","category":"page"},{"location":"man/mutation.html","page":"Mutation operators","title":"Mutation operators","text":"Currently, mutation is only implemented for vector individuals.","category":"page"},{"location":"man/mutation.html#Selecting-a-mutation-operator","page":"Mutation operators","title":"Selecting a mutation operator","text":"","category":"section"},{"location":"man/mutation.html","page":"Mutation operators","title":"Mutation operators","text":"warning: Deprecated from EvoLP 1.4\nAll mutation operators have been renamed to mutators since EvoLP 1.4. The old names will be deprecated in a future major release. Be sure to check the new type ontology.","category":"page"},{"location":"man/mutation.html","page":"Mutation operators","title":"Mutation operators","text":"EvoLP provides many built-in mutators.","category":"page"},{"location":"man/mutation.html#For-binary-vectors","page":"Mutation operators","title":"For binary vectors","text":"","category":"section"},{"location":"man/mutation.html#EvoLP.BitwiseMutator","page":"Mutation operators","title":"EvoLP.BitwiseMutator","text":"Bitwise mutation with probability λ of flipping each bit.\n\n\n\n\n\n","category":"type"},{"location":"man/mutation.html#For-continuous-vectors","page":"Mutation operators","title":"For continuous vectors","text":"","category":"section"},{"location":"man/mutation.html#EvoLP.GaussianMutator","page":"Mutation operators","title":"EvoLP.GaussianMutator","text":"Gaussian mutation with standard deviation σ, which should be a real number.\n\n\n\n\n\n","category":"type"},{"location":"man/mutation.html#For-permutation-based-vectors","page":"Mutation operators","title":"For permutation-based vectors","text":"","category":"section"},{"location":"man/mutation.html#EvoLP.SwapMutator","page":"Mutation operators","title":"EvoLP.SwapMutator","text":"Swap mutation for permutation-based individuals.\n\n\n\n\n\n","category":"type"},{"location":"man/mutation.html#EvoLP.InsertionMutator","page":"Mutation operators","title":"EvoLP.InsertionMutator","text":"Insert mutation for permutation-based individuals.\n\n\n\n\n\n","category":"type"},{"location":"man/mutation.html#EvoLP.ScrambleMutator","page":"Mutation operators","title":"EvoLP.ScrambleMutator","text":"Scramble mutation for permutation-based individuals.\n\n\n\n\n\n","category":"type"},{"location":"man/mutation.html#EvoLP.InversionMutator","page":"Mutation operators","title":"EvoLP.InversionMutator","text":"Inversion mutation for permutation-based individuals.\n\n\n\n\n\n","category":"type"},{"location":"man/mutation.html#Performing-the-mutation","page":"Mutation operators","title":"Performing the mutation","text":"","category":"section"},{"location":"man/mutation.html","page":"Mutation operators","title":"Mutation operators","text":"After \"instantiating\" a mutation method, you can use mutate on a single individual ind. All operators return a copy, and in the process no individual is modified.","category":"page"},{"location":"man/mutation.html#EvoLP.mutate","page":"Mutation operators","title":"EvoLP.mutate","text":"mutate(M::BitwiseMutator, ind)\n\nRandomly flips each bit with a probability λ.\n\n\n\n\n\nmutate(M::GaussianMutator, ind)\n\nRandomly add Gaussian noise to the ind candidate solution, with a standard deviation of σ.\n\n\n\n\n\nmutate(::SwapMutator, ind)\n\nRandomly swap the position of two alleles in the ind candidate solution.\n\n\n\n\n\nmutate(::InsertionMutator, ind)\n\nRandomly choose two positions a and b from ind, insert at a+1 the element at position b`, and shift the rest of the elements.\n\n\n\n\n\nmutate(::ScrambleMutator, ind)\n\nRandomly scramble the subsequence between two random points in ind.\n\n\n\n\n\nmutate(::InversionMutator, ind)\n\nInvert the subsequence between two random points in ind.\n\n\n\n\n\n","category":"function"},{"location":"tuto/8_queens.html#Solving-the-8-queens-problem","page":"The 8 queens problem","title":"Solving the 8-queens problem","text":"","category":"section"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"This tutorial will showcase how to use some of the building blocks provided by LP to solve a combinatorial problem.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"In this example,  we will solve the 8-queens puzzle. This is a constraint satisfaction problem in which the goal is to place 8 queens in a chess board such that neither of them check each other.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"(Image: One queen on the board)","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"In the figure above, we have placed a queen represented by a blue dot. All conflicting cells have been highlighted. The problem becomes harder when we add more queens to the board:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"(Image: 2 queens on the board)","category":"page"},{"location":"tuto/8_queens.html#Implementing-the-solution","page":"The 8 queens problem","title":"Implementing the solution","text":"","category":"section"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We can solve this problem using a Genetic Algorithm (GA) that deals with the constraints, using a steady-state approach and logging statistics on every iteration.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We will use the following modules:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"using Statistics\nusing EvoLP\nusing OrderedCollections","category":"page"},{"location":"tuto/8_queens.html#Dealing-with-constraints","page":"The 8 queens problem","title":"Dealing with constraints","text":"","category":"section"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"To implement the solution, we need to handle the constraints in some way. For this problem, we can divide the constraints in vertical, horizontal and diagonal clashes between the queens.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Interestingly enough, the vertical and horizontal clashes can be dealt with by using a vector of permutations where the genes (index of the vector) represent a column and the alleles (values the index can take) represent the row used in that column:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"(Image: A possible representation of the 8-queens problem)","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"For the phenotype above, the genotype representation would look like this:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"x = [1, 3, 5, 2, 6, 4, 7, 8]","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"The queen in the first column is in row 1. The queen in the second column is in row 3, and so on.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"EvoLP contains a convenient permutation_vector_pop:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"permutation_vector_pop","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"julia> @doc permutation_vector_pop","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We can now use the generator to initialise our population:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"pop_size = 100\npopulation = permutation_vector_pop(pop_size, 8, 1:8)\nfirst(population, 3)","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"3-element Vector{Vector{Int64}}:\n    [3, 7, 4, 8, 2, 1, 5, 6]\n    [5, 4, 7, 6, 2, 3, 1, 8]\n    [8, 6, 5, 1, 2, 3, 4, 7]","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"To deal with the diagonal constraints, we can use the fitness function.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"The penalty of a queen is the number of queens she can check. The penalty of a board configuration would then be the sum of all penalties of all queens, and this is what we want to minimise. So let's build our fitness function step by step.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Assume a queen q is in a position (i j). Then, we can define the diagonal neighbourhood as the following:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Top-left: (i-1 j-1)\nTop-right: (i-1 j+1)\nBottom-left: (i+1 j-1)\nBottom-right: (i+1 j+1)","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We can then use this information to iterate in all directions and check how many queens are there in the diagonals.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"If we do this for every queen q, then we will count some of the clashes twice. It is a good idea to create a set of these clashes so that we can sum them afterwards.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"function diag_constraints(x)\n    # rows are values in x\n    # columns are indices from 1:8\n    fitness = []\n    for q in 1:8\n        tl = collect(zip(x[q]:-1:1, q:-1:1))\n        tr = collect(zip(x[q]:-1:1, q:1:8))\n        bl = collect(zip(x[q]:1:8, q:-1:1))\n        br = collect(zip(x[q]:1:8, q:1:8))\n\n        constraints = Set(vcat(tl, tr, bl, br))\n        delete!(constraints, (x[q], q))\n        q_fit = sum([(i, j) in constraints ? 1 : 0 for (i, j) in zip(x, 1:8)])\n        push!(fitness, q_fit)\n    end\n\n    return sum(fitness)\nend","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"To handle the corners and not specify \"emtpy\" diagonals, we consider the position (ij) of a queen to count as a \"clash\" itself. This means that a queen in (11) will consider (11) as the top-left diagonal, and (ii) i in 18 as the bottom-right diagonal (again, including itself). We later remove these additional constraints via delete! and proceed normally.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Using the same configuration as before, we have the following conflicting positions:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"(Image: Conflicts of the previous configuration are highlighted)","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We can test our fitness function diag_constraints on this board and see the number of conflicts in total:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"test = [1, 3, 5, 2, 6, 4, 7, 8]\ndiag_constraints(test)","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"10","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Going through each queen q_i (with i being the column number), we have the following number of conflicts: q_1 = 2, q_2 = 1, q_3 = 0, q_4 = 1, q_5 = 1, q_6 = 1, q_7 = 2,  q_8 = 2","category":"page"},{"location":"tuto/8_queens.html#Evolutionary-operators","page":"The 8 queens problem","title":"Evolutionary operators","text":"","category":"section"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We now need to choose our evolutionary operators: what we will use for selection, crossover and mutation.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"However, since we're dealing with permutations, we are restricted to use specific operators that do not end up destroying feasible solutions and therefore violate our constraints. EvoLP contains some operators that can deal with permutation-based individuals:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"julia> @doc TournamentSelector","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Tournament parent selection with tournament size ``k``.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"julia> @doc OX1Recombinator","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Order 1 crossover (OX1) for permutation-based individuals.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"julia> @doc SwapMutator","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Swap mutation for permutation-based individuals.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We can now instantiate them and continue.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"S = TournamentSelector(5);\nC = OX1Recombinator();\nM = SwapMutator();","category":"page"},{"location":"tuto/8_queens.html#Logging-statistics","page":"The 8 queens problem","title":"Logging statistics","text":"","category":"section"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We can use the Logbook to record statistics about our run:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"statnames = [\"mean_eval\", \"max_f\", \"min_f\", \"median_f\"]\nfns = [mean, maximum, minimum, median]\nthedict = LittleDict(statnames, fns)\nthelogger = Logbook(thedict)","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Logbook(LittleDict{AbstractString, Function, Vector{AbstractString}, Vector{Function}}(\"mean_eval\" => Statistics.mean, \"max_f\" => maximum, \"min_f\" => minimum, \"median_f\" => Statistics.median), NamedTuple{(:mean_eval, :max_f, :min_f, :median_f)}[])","category":"page"},{"location":"tuto/8_queens.html#Constructing-our-own-algorithm","page":"The 8 queens problem","title":"Constructing our own algorithm","text":"","category":"section"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"And now we are ready to use all our building blocks to construct our own algorithm. In this case, we will use a steady-state GA: instead of replacing the whole population, we will generate a fixed amount of candidate solutions and keep the best n individuals in the population each iteration.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"Let's do a summary then:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"The representation is a vector of permutations of integers with values in the closed range 18.\nTo select the parents, we use the TournamentSelector operator with a tournament size of 5.\nTo recombine the parents, we use the OX1Recombinator operator.\nTo mutate a candidate solution, we use the SwapMutator operator.\nTo select the survivors, we replace the worst individuals.\nWith a population size pop_size of 100.\nWith a random initialisation using the generator permutation_vector_pop.\nWe will use a crossover probability of 100%.\nAnd a mutation probability of 80%.","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"We can then build our algorithm in a function, and use EvoLP's Result type for the return:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"function mySteadyGA(logbook, f, pop, k_max, S, C, M, mrate)\n    n = length(pop)\n    # Generation loop\n    for _ in 1:k_max\n        fitnesses = f.(pop)\n        parents = select(S, fitnesses)  # this will return 2 parents\n        parents = vcat(parents, select(S, fitnesses))  # Extend the list with 2 more parents\n        offspring = [cross(C, pop[parents[1]], pop[parents[2]])]  # get first kid\n        offspring = vcat(offspring, [cross(C, pop[parents[3]], pop[parents[4]])])  # get 2nd\n        pop = vcat(pop, offspring) # add to population\n        \n        # Mutation loop\n        for i in eachindex(pop)\n            if rand() <= mrate\n                pop[i] = mutate(M, pop[i])\n            end\n        end\n        fitnesses = f.(pop)\n\n        # Log statistics\n        compute!(logbook, fitnesses)\n\n        # Find worst and remove\n        worst1 = argmax(fitnesses)\n        deleteat!(pop, worst1)\n        deleteat!(fitnesses, worst1)\n        \n        # And do the same again\n        worst2 = argmax(fitnesses)\n        deleteat!(pop, worst2)\n        deleteat!(fitnesses, worst2)\n    end\n\n    # Result reporting\n    best, best_i = findmin(f, pop)\n    n_evals = 2 * k_max * n + n\n    result = Result(best, pop[best_i], pop, k_max, n_evals)\n    return result\nend","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"To try our new algorithm, we just need to call its function with the appropriate arguments:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"result  = mySteadyGA(thelogger, diag_constraints, population, 500, S, C, M, 0.8);","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"EvoLP provides convenient functions that we can use to get information about a result:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"@show optimum(result)\n@show optimizer(result)\n@show f_calls(result)\nthelogger.records[end]","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"optimum(result) = 0\noptimizer(result) = Any[5, 1, 8, 6, 3, 7, 2, 4]\nf_calls(result) = 100100\n\n\n\n(mean_eval = 9.392156862745098, max_f = 20, min_f = 0, median_f = 8.0)","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"And this is just a helper function to visualise our result as a chess board:","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"function drawboard(x)\n    b = fill(\"◻\",8,8)\n    for i in 1:2:8\n        b[i,2:2:8] .= \"◼\"\n    end\n    for i in 2:2:8\n        b[i, 1:2:8] .= \"◼\"\n    end\n    for (i,j) in zip(x,1:8)\n        b[i, j] = \"♛\"\n    end\n    for i in 1:8\n        println(join(b[i,:]))\n    end\nend","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"drawboard(optimizer(result))","category":"page"},{"location":"tuto/8_queens.html","page":"The 8 queens problem","title":"The 8 queens problem","text":"◻♛◻◼◻◼◻◼\n◼◻◼◻◼◻♛◻\n◻◼◻◼♛◼◻◼\n◼◻◼◻◼◻◼♛\n♛◼◻◼◻◼◻◼\n◼◻◼♛◼◻◼◻\n◻◼◻◼◻♛◻◼\n◼◻♛◻◼◻◼◻","category":"page"},{"location":"tuto/ga_rosenbrock.html#Generational-GA-for-continuous-optimisation","page":"GA for continuous optimisation","title":"Generational GA for continuous optimisation","text":"","category":"section"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"This tutorial details how to use the built-in Genetic Algorithm (GA) on a continuous test function.","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"We start by importing EvoLP. We will compute some statistics using the Logbook so we need some additional modules as well:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"using Statistics\nusing EvoLP\nusing OrderedCollections","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"For this example we will use the Rosenbrock function, which is already included as a benchmark function in EvoLP. We can look at the documentation like so:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"@doc rosenbrock","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"rosenbrock(x; b=100)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"The d-dimensional Rosenbrock banana benchmark function. With b=100, minimum is at f(1 dots 1) = 0f(x) = sum_i=1^d-1 leftb(x_i+1 - x_i^2)^2 + (x_i - 1)^2 right","category":"page"},{"location":"tuto/ga_rosenbrock.html#Implementing-the-solution","page":"GA for continuous optimisation","title":"Implementing the solution","text":"","category":"section"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"Let's start creating the population. We can  use the normal_rand_vector_pop generator, which uses a normal distribution for initialisation:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"@doc normal_rand_vector_pop","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"normal_rand_vector_pop(n, μ, Σ; rng=Random.GLOBAL_RNG)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"Generate a population of n vector individuals using a normal distribution with means μ and covariance Σ. μ expects a vector of length l (i.e. length of an individual) while Σ expects an l x l matrix of covariances.","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"The rosenbrock in our case is 2D, so we need a vector of 2 means, and a matrix of 2x2 covariances:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"pop_size = 50\npopulation = normal_rand_vector_pop(pop_size, [0, 0], [1 0; 0 1])\nfirst(population, 3)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"3-element Vector{Vector{Float64}}:\n [-0.25289759101653736, 1.0150132241600427]\n [-0.9053394512418402, 0.6058801355483802]\n [0.5784934203305488, -0.20665678122470943]","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"In a GA, we have selection, crossover and mutation.","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"We can easily set up these operators using the built-ins provided by EvoLP. Let's use rank based selection and interpolation crossover with 0.5 as the scaling factor:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"@doc InterpolationRecombinator","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"Interpolation crossover with scaling parameter λ.","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"S = RankBasedSelector()\nC = InterpolationRecombinator(0.5)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"InterpolationRecombinator(0.5)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"For mutation, we can use Gaussian noise:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"@doc GaussianMutator","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"Gaussian mutation with standard deviation σ, which should be a real number.","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"M = GaussianMutator(0.05)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"GaussianMutator(0.05)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"Now we can set up the Logbook to record statistics about our run:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"statnames = [\"mean_eval\", \"max_f\", \"min_f\", \"median_f\"]\nfns = [mean, maximum, minimum, median]\nthedict = LittleDict(statnames, fns)\nthelogger = Logbook(thedict)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"Logbook(LittleDict{AbstractString, Function, Vector{AbstractString}, Vector{Function}}(\"mean_eval\" => Statistics.mean, \"max_f\" => maximum, \"min_f\" => minimum, \"median_f\" => Statistics.median), NamedTuple{(:mean_eval, :max_f, :min_f, :median_f)}[])","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"And now we're ready to use the GA built-in algorithm:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"@doc GA","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"GA(f::Function, population, k_max, S, C, M)\nGA(logbook::Logbook, f::Function, population, k_max, S, C, M)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"Generational Genetic Algorithm.Argumentsf: Objective function to minimise\npopulation: a list of individuals.\nk_max: maximum iterations\nS::Selector: a selection method. See selection.\nC::Recombinator: a crossover method. See crossover.\nM::Mutator: a mutation method. See mutation.Returns a Result.","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"result = GA(thelogger, rosenbrock, population, 300, S, C, M);","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"The output was suppressed so that we can analyse each part of the result separately using functions instead:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"@show optimum(result)\n\n@show optimizer(result)\n\n@show f_calls(result)\n\nthelogger.records[end]","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"optimum(result) = 0.00015325530365919114\noptimizer(result) = [0.9295343671510049, 0.9158201966396184]\nf_calls(result) = 25000\n\n(mean_eval = 0.07544433008393486, max_f = 0.43255087263181813, min_f = 0.00015325530365919114, median_f = 0.0424343220731829)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"The records in the Logbook are NamedTuples. This makes it easier to export and analyse using DataFrames, for example:","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"using DataFrames\nDataFrame(thelogger.records)","category":"page"},{"location":"tuto/ga_rosenbrock.html","page":"GA for continuous optimisation","title":"GA for continuous optimisation","text":"500×4 DataFrame\n Row │ mean_eval   max_f       min_f        median_f  \n     │ Float64     Float64     Float64      Float64   \n─────┼────────────────────────────────────────────────\n   1 │ 22.0251     406.9       0.447041     6.78992\n   2 │  3.61617     36.062     0.124031     1.96466\n   3 │  1.13189      3.18343   0.127583     1.07601\n   4 │  0.781777     1.6644    0.309661     0.711803\n   5 │  0.593735     0.935043  0.294026     0.588684\n   6 │  0.527621     0.766033  0.315916     0.518089\n   7 │  0.522381     0.745129  0.37027      0.527158\n   8 │  0.493569     0.807639  0.275269     0.498038\n  ⋮ │     ⋮           ⋮            ⋮           ⋮","category":"page"},{"location":"man/testfunctions.html#Optimisation-test-functions","page":"Optimisation test functions","title":"Optimisation test functions","text":"","category":"section"},{"location":"man/testfunctions.html","page":"Optimisation test functions","title":"Optimisation test functions","text":"EvoLP includes some test functions to benchmark your algorithms. Unless otherwise specified, every function is of the form f(x).","category":"page"},{"location":"man/testfunctions.html#Pseudo-boolean-functions","page":"Optimisation test functions","title":"Pseudo boolean functions","text":"","category":"section"},{"location":"man/testfunctions.html#EvoLP.onemax","page":"Optimisation test functions","title":"EvoLP.onemax","text":"The OneMax function returns the sum of the individual. For an individual of length n, maximum is achieved with n ones.\n\ntextOneMax(mathbfx) = sum_i=1^n x_i\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.leadingones","page":"Optimisation test functions","title":"EvoLP.leadingones","text":"The LeadingOnes function returns the number of uninterrupted ones from the start of the chromosome. The maximum is achieved with n ones, but the landscape is a bit more difficult to traverse.\n\ntextLO(mathbfx) = sum_i=1^n prod_j^i x_j\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.jumpk","page":"Optimisation test functions","title":"EvoLP.jumpk","text":"jumpk(x; k=6)\n\nThe JumpK function is a modification of the onemax function, with a valley of size k right before the maximum. The only way for a hill climber to reach the maximum is with a perfect flip of k bits, which is considered extremely difficult.\n\ntextJUMP_k(x) = begincases\nlVertxrVert_1  quad textif  lVert x rVert_1 in 0n-k cup n\n-lVert x rVert_1  quad textotherwise\nendcases\n\nwhere lVert x rVert_1 = sum_i=1^n x_i is the number of 1-bits in x in 0 1^n.\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#Continuous-functions","page":"Optimisation test functions","title":"Continuous functions","text":"","category":"section"},{"location":"man/testfunctions.html","page":"Optimisation test functions","title":"Optimisation test functions","text":"Continuous functions implementations were taken from Kochenderfer, M.J. and Wheeler, T.A. (2019). Most of these can be visualised in Surjanovic, S. & Bingham, D. (2013).","category":"page"},{"location":"man/testfunctions.html#EvoLP.ackley","page":"Optimisation test functions","title":"EvoLP.ackley","text":"ackley(x; a=20, b=0.2, c=2π)\n\nAckley's benchmark function. Global minimum is at the origin, with value of 0. Parameters are typically a=20, b=02, and c=2pi.\n\nf(x) = -a expleft(-bsqrtfrac1d sum_i=1^d x_i^2right)\n- expleft(frac1d sum_i=1d cos (cx_i) right) + a + exp(1)\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.booth","page":"Optimisation test functions","title":"EvoLP.booth","text":"The Booth function is a 2-dimensional quadratic function with global minimum x^* = 1 3 and optimal value f(x^*) = 0.\n\nf(x) = (x_1 + 2x_2 - 7)^2 + (2 x_1 + x_2 - 5)^2\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.branin","page":"Optimisation test functions","title":"EvoLP.branin","text":"branin(x; a=1, b=5.1/(4π^2), c=5/π, r=6, s=10, t=1/(8π))\n\nThe Branin (a.k.a. Branin-Hoo) function has six optional parameters, and features multiple global minima. Some of them are at x^* = -pi 12275, x^* = pi 2275, x^* = 3pi 2475 and x^* = 5pi 12875, with f(x^*) approx 0397887.\n\nf(x) = a(x_2 - bx_1^2 + cx_1 - r)^2 + s(1 - t)cos(x_1) + s\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.circle","page":"Optimisation test functions","title":"EvoLP.circle","text":"circle(x)\n\nwarning: Deprecated from EvoLP 1.3\nThis test function will be deprecated in a future major release.\n\nThe circle function is a multiobjective test function, given by\n\nf(x) = beginbmatrix\n        1 - rcos(theta) \n        1 - rsin(theta)\n        endbmatrix\n\nwhere theta=x_1 and r is obtained by\n\nr = frac12 + frac12 left(frac2x_21+x_2^2right)\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.eggholder","page":"Optimisation test functions","title":"EvoLP.eggholder","text":"eggholder(x::Vector{T} where {T<:Real})\n\nA d-dimensional function which draws its name due to its highly rugged landscape. For the 2-dimensional version, the optimum f(mathbfx^*)approx-95964066 with optimiser mathbfx^* = (512 404231805).\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.flower","page":"Optimisation test functions","title":"EvoLP.flower","text":"flower(x; a=1, b=1, c=4)\n\nwarning: Deprecated from EvoLP 1.3\nThis function will be deprecated in a future major release.\n\nThe flower function is a two-dimensional test function with flower-like contour lines coming out from the origin. Typically, optional parameters are set at a=1, b=1 and c=4. The function is minimised near the origin, although it does not have a global minimum due to atan bein undefined at 0 0.\n\nf(x) = alVertmathbbxrVert + b sin(carctan(x_2 x_1))\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.michalewicz","page":"Optimisation test functions","title":"EvoLP.michalewicz","text":"michalewicz(x; m=10)\n\nThe Michalewicz function is a d-dimensional function with several steep valleys, where m controls the steepness. m is usually set at 10. For 2 dimensions, x^* = 220 157, with f(x^*) = -18011.\n\nf(x) = -sum_i=1^dsin(x_i) sin^2mleft(fracix_i^2piright)\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.rana","page":"Optimisation test functions","title":"EvoLP.rana","text":"rana(x::Vector{T} where {T<:Real})\n\nA d-dimensional function which is highly rugged and symmetrical. For d=2, the global minimum f(mathbfx^*)approx -51173288 with optimiser\\mathbf{x}^* = (-488.632577, 512).\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.rosenbrock","page":"Optimisation test functions","title":"EvoLP.rosenbrock","text":"rosenbrock(x; b=100)\n\ncompat: Changed since EvoLP 1.3\nThis is the d-dimensional Rosenbrock function. In previous releases, it was 2d only and had an additional keyword argument a.Update your workflow accordingly.\n\nThe d-dimensional Rosenbrock banana benchmark function. With b=100, minimum is at f(1 dots 1) = 0\n\nf(x) = sum_i=1^d-1 leftb(x_i+1 - x_i^2)^2 + (x_i - 1)^2 right\n\n\n\n\n\n","category":"function"},{"location":"man/testfunctions.html#EvoLP.wheeler","page":"Optimisation test functions","title":"EvoLP.wheeler","text":"wheeler(x, a=1.5)\n\nThe Wheeler's ridge is a 2-d function with a single global minimum in a curved peak. With a (by default at 1.5) x^* = 1 15, with f(x^*) = -1.\n\nf(x) = - exp(- (x_1 x_2 - a)^2 - (x_2 - a)^2 )\n\n\n\n\n\n","category":"function"},{"location":"tuto/parallel.html#Parallel-Evaluation-in-EvoLP.jl","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"","category":"section"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Evaluation of multiple solutions in parallel can dramatically reduce computational time. This tutorial will illustrate how to do so with Threads and MPI. However, you might also want to check Julia's built-in Distributed module.","category":"page"},{"location":"tuto/parallel.html#Threads","page":"Parallel Evaluation in EvoLP.jl","title":"Threads","text":"","category":"section"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Julia has built-in multithreaded support via the Base.Threads package.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"First, make sure you are running Julia with several threads.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"details: Details\nBy using the the -t option, Julia can be started with several threads. For example, julia -t 4 will start Julia with 4 threads.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Then, you can add the @threads macro to the evaluation loop of your algorithms:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"# generate population\n# set selection, crossover and mutation operators\n# set fitness function f\nN = length(population)\nfitnesses = zeros(N)\n@threads for i in eachindex(fitnesses)\n    fitnesses[i] = f(population[i])\nend\n# do selection, crossover, mutation...\n# repeat","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"The scheduler will automatically spawn and sync all available threads to Julia in order to finish the computation. This is the easiest way to do parallel computations with EvoLP, but it is limited to a single physical processor. If you need many more processes/cores, consider using Distributed or MPI.","category":"page"},{"location":"tuto/parallel.html#MPI","page":"Parallel Evaluation in EvoLP.jl","title":"MPI","text":"","category":"section"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"note: Note\nThis is a somewhat advanced topic, as you need to specify and handle the communication between processors yourself. However, it can scale very well, up to HPC clusters.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"MPI (short for Message Passing Interface) is a library interface specification that addresses the parallel model in which data moves between computers through messages. It is one of the most widely used standards for parallel programming in High-Performance Computing (HPC) systems, and so it is available on many clusters. Nevertheless, you can run MPI on your local device as well.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"In EvoLP, we use the MPI bindings for Julia included in the MPI.jl package. It is important to remark that EvoLP does not load MPI.jl by default. Instead, it is used as an extension, so it will be available if you load MPI.jl in your code along with EvoLP.jl.","category":"page"},{"location":"tuto/parallel.html#Installing-MPI-Locally","page":"Parallel Evaluation in EvoLP.jl","title":"Installing MPI Locally","text":"","category":"section"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"For installation and configuration, kindly follow the steps defined in the MPI.jl documentation.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Nonetheless, you might be able to install it through a package manager. We have tested the MPICH implementation on both Ubuntu 22 (using apt) and Fedora 42 (using dnf).","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"In some cases, the MPICH package might get installed as in a SLURM cluster. In such situations, the module needs to be loaded first to see the available executables:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"$ module load mpi","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"This will allow the mpiexec and mpirun commands&mdash;which are needed to execute Julia scripts in parallel&mdash;to become available in your shell.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"We highly suggest that you try first the MPI.jl Basic Example.","category":"page"},{"location":"tuto/parallel.html#Island-Models-using-MPI","page":"Parallel Evaluation in EvoLP.jl","title":"Island Models using MPI","text":"","category":"section"},{"location":"tuto/parallel.html#Step-1:-Code-your-island","page":"Parallel Evaluation in EvoLP.jl","title":"Step 1: Code your island","text":"","category":"section"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"If you have not done so, please read the documentation page on island models.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Assume you have a very basic island model using the following settings:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"An archipelago with 4 islands, optimising the michalewicz function. All islands are identical, and each island features:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"A population P of N=30 2-dimensional vectors (individuals)\nwhere P sim mathcalU(boldsymbolx  boldsymbolx in mathbbR^2 x in 0 pi)\nA rank-based selector: RankBasedSelector\nA uniform crossover operator: UniformRecombinator\nA Gaussian mutation operator with sigma = 01: GaussianMutator","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"The algorithm will run for 100 iterations, and every mu=10 iterations, it will send a deme of 10% of the population size, i.e., k=01N (3 individuals). It will select the k individuals at random, and will replace the worst k individuals in the new island.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"The migration topology is a ring, so each island will send its deme to the next island:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"1 to 2 to 3 to 4 to 1","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Then, the code would look similar to this:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"using EvoLP  # Load EvoLP\nusing OrderedCollections\nusing MPI  # Load MPI.jl!\nusing Statistics\n\nMPI.Init()  # Initialize MPI\n\ncomm = MPI.COMM_WORLD  # Initialize the MPI communication world\nranks = MPI.Comm_size(comm)  # Create a rank for each island\nmyrank = MPI.Comm_rank(comm)  # Assign each island to its rank\n\ndest = mod(myrank+1, ranks)  # Set destination (Deme I am sending)\nsrc = mod(myrank-1, ranks)  # Set source (Deme I am receiving)\n\n# GA operators\nN = 30\nS_P = RankBasedSelector()\nX = UniformRecombinator()\nMut = GaussianMutator(0.1)\nmax_it = 100\n\n# Island operators\nk = 0.1*N # deme size\nS_M = RandomDemeSelector(k)  # migration selection policy\nR_M = WorstDemeSelector(k)  # migration replacement policy\nμ = 10  # number of iterations between migration\n\nP = unif_rand_vector_pop(N, [0, 0], [π, π])\n\nthelog = Logbook()\n\nres = islandGA!(thelog, michalewicz, P, max_it, S_P, X, Mut, μ, S_M, R_M, dest, src, comm)\n\nprint(\"\"\"Result on run from rank $(myrank) was $(optimum(res)) achieved by $(optimizer(res))\\n\"\"\")","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"In this snippet of code, we are using the toy built-in algorithm islandGA!.","category":"page"},{"location":"tuto/parallel.html#Step-2:-Run-your-model","page":"Parallel Evaluation in EvoLP.jl","title":"Step 2: Run your model","text":"","category":"section"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Once the script is finished, you can run it using MPI from the terminal. Assuming our script is called scratch.jl:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"You can run it using mpiexec, as such:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"$ mpiexec -n 4 julia --project=./ ./scratch.jl","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Notice we are using -n 4 to run 4 islands, but this is where MPI really shines as it can scale very easily.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"The result should look something like this:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"$ mpiexec -n 4 julia --project=./ ./scratch.jl\nResult on run from rank 0 was -1.7918109629302714 achieved by [2.1799811139347045, 1.5759514028959793]\nResult on run from rank 1 was -1.7687392718383559 achieved by [2.2092215285901076, 1.5988409423611978]\nResult on run from rank 3 was -1.784211505064787 achieved by [2.213698645080214, 1.5512366106384692]\nResult on run from rank 2 was -1.7738196053483932 achieved by [2.2115479736169856, 1.54495573080501]","category":"page"},{"location":"tuto/parallel.html#Running-on-an-HPC-cluster","page":"Parallel Evaluation in EvoLP.jl","title":"Running on an HPC cluster","text":"","category":"section"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"warning: Warning\nEach HPC system is different, so you might need to adapt these instructions. Nevertheless, this is a good starting point.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"We have tested EvoLP using SLURM. Assuming you have a julia module available, then the process is very similar to the steps above. You can submit an bash script similar to this:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"#!/usr/bin/bash\n#SBATCH -J julia-mpi-test\n#SBATCH -n 64\n#SBATCH -c 1\n\nmodule load foss/2022b\nmodule load Julia/1.9.3-linux-x86_64\n\nsrun julia scratch.jl","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Which can then submitted as:","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"$ sbatch myjuliajob.sh","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Assuming you named your bash script as myjuliajob.sh. Note that the module foss/2022b is one of many modules that include MPI. intel-compilers is another module that normally includes MPI as well. In our script, the srun command will run the scratch.jl julia script that corresponds to an island. Then, it will create -n 64 copies of the script, and run them in  the MPI world.","category":"page"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Again, each HPC system is different, and the modules and tricks available are usually specific to each system. You might have to experiment a bit.","category":"page"},{"location":"tuto/parallel.html#Further-Reading","page":"Parallel Evaluation in EvoLP.jl","title":"Further Reading","text":"","category":"section"},{"location":"tuto/parallel.html","page":"Parallel Evaluation in EvoLP.jl","title":"Parallel Evaluation in EvoLP.jl","text":"Distributed: Julia's built-in distributed computing module\nThe MPI.jl documentation.\nOur paper Evolutionary Computation with Islands: Extending EvoLP.jl for Parallel Computing.","category":"page"},{"location":"man/results.html#Reporting-results","page":"Reporting results","title":"Reporting results","text":"","category":"section"},{"location":"man/results.html","page":"Reporting results","title":"Reporting results","text":"EvoLP provides a type for reporting results that you can use as the return vale of an algorithm. The type has different data fields conveniently stored in a single variable, which allows for further inspection if desired (for example for post-mortem visualisation and analysis.)","category":"page"},{"location":"man/results.html#EvoLP.Result","page":"Reporting results","title":"EvoLP.Result","text":"A type for reporting results of an algorithm. In order, these are:\n\nthe optimum f(x^*)\nthe optimizer x^*\nthe population\nthe number of iterations\nthe number of function calls\nthe runtime.\n\n\n\n\n\n","category":"type"},{"location":"man/results.html","page":"Reporting results","title":"Reporting results","text":"Some getter functions are also included to obtain specific information about the result.","category":"page"},{"location":"man/results.html#EvoLP.optimum","page":"Reporting results","title":"EvoLP.optimum","text":"optimum(result)\n\nReturns evaluation of solution found f(x^*).\n\n\n\n\n\n","category":"function"},{"location":"man/results.html#EvoLP.optimizer","page":"Reporting results","title":"EvoLP.optimizer","text":"optimizer(result)\n\nReturns solution found x^*.\n\n\n\n\n\n","category":"function"},{"location":"man/results.html#EvoLP.population","page":"Reporting results","title":"EvoLP.population","text":"population(res::Result)\n\nReturns the resulting population of the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"man/results.html#EvoLP.iterations","page":"Reporting results","title":"EvoLP.iterations","text":"iterations(res::Result)\n\nReturns the number of iterations of a result.\n\n\n\n\n\n","category":"function"},{"location":"man/results.html#EvoLP.f_calls","page":"Reporting results","title":"EvoLP.f_calls","text":"f_calls(res::Result)\n\nReturns number of function evaluation calls of a result.\n\n\n\n\n\n","category":"function"},{"location":"man/results.html#EvoLP.runtime","page":"Reporting results","title":"EvoLP.runtime","text":"runtime(res::Result)\n\nReturns the resulting runtime of the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"man/results.html","page":"Reporting results","title":"Reporting results","text":"All built-in algorithms in EvoLP use the Result as their return value.","category":"page"},{"location":"man/quickstart.html#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"EvoLP was designed as a playground, where each block is a reusable computation pattern that you can use to quickly set up your own algorithms and workflows.","category":"page"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"You can find some useful tutorials in the navigation bar. These examples are also available in the repository as Jupyter Notebooks. The tutorial on the 8 queens problem details how to incorporate a custom algorithm into the workflow. If you want to use custom blocks, you can do that too.","category":"page"},{"location":"man/quickstart.html#Installation-Guide","page":"Quick start","title":"Installation Guide","text":"","category":"section"},{"location":"man/quickstart.html#Install-Julia","page":"Quick start","title":"Install Julia","text":"","category":"section"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"EvoLP is a package for Julia. To use EvoLP, download and install the latest version of Julia first.","category":"page"},{"location":"man/quickstart.html#Install-EvoLP","page":"Quick start","title":"Install EvoLP","text":"","category":"section"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"You can install EvoLP from the Julia REPL using the built-in package manager:","category":"page"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"julia> import Pkg\njulia> Pkg.add(\"EvoLP\")","category":"page"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"Alternatively, you can enter Pkg mode by pressing the ] key and then add EvoLP like so:","category":"page"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"] # upon typing ], the prompt changes (in place) to: pkg>\nadd EvoLP","category":"page"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"Once EvoLP is installed, you can use all the building blocks by importing/using it at the top of your code:","category":"page"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"using EvoLP\n\n# your code here","category":"page"},{"location":"man/quickstart.html#The-general-workflow","page":"Quick start","title":"The general workflow","text":"","category":"section"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"A common workflow in EvoLP is somewhat similar to this:","category":"page"},{"location":"man/quickstart.html","page":"Quick start","title":"Quick start","text":"Use a generator for initialising your population.\nCode your objective or use a test benchmark function.\nDepending on your objective function and individual representation, choose appropriate selectors, recombinators and mutators.\nUse a built-in algorithm or code your own. Roughly:\nEvaluate your population.\nUse select and cross to generate new solutions.\nStochastically alter new solutions using mutate.\nEvaluate the new population members and select the survivors.\nOptionally compute statistic and log them in the Logbook.\nReturn the results.","category":"page"},{"location":"tuto/pso_michalewicz.html#Using-PSO-to-minimise-the-Michalewicz-function","page":"PSO for continuous optimisation","title":"Using PSO to minimise the Michalewicz function","text":"","category":"section"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"This tutorial showcases how to use the built-in Particle Swarm Optimisation (PSO) algorithm for finding the minimum in a continuos setting.","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"We start by importing our necessary modules","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"using EvoLP\nusing Statistics\nusing OrderedCollections","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"For this example, we will use the Michalewicz function, which is a test function included in EvoLP:","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"@doc michalewicz","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"michalewicz(x; m=10)","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"The Michalewicz function is a d-dimensional function with several steep valleys, where m controls the steepness. m is usually set at 10. For 2 dimensions, x^* = 220 157, with f(x^*) = -18011.f(x) = -sum_i=1^dsin(x_i) sin^2mleft(fracix_i^2piright)","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"In this case we will use d=2 and m=10, which are the default values implemented.","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"In PSO, we use particles. Each particle has a position and a velocity, and remembers the best position the whole swarm has visited. We can create a population of particles in multiple ways, but EvoLP provides 2 particle generators with random positions: either uniform or following a normal distribution.","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"Let's use the normal generator:particle generators","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"@doc normal_rand_particle_pop","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"normal_rand_particle_pop(n, μ, Σ; rng=Random.GLOBAL_RNG)","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"Generate a population of n Particle using a normal distribution with means μ and covarianceΣ. μ expects a vector of length l (i.e. number of dimensions) while Σ expects an l x l matrix of covariances.","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"Since we are using the 2-dimensional version of the function, we need to provide a vector of 2 means and a 2 \\times 2 matrix of covariances:","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"population = normal_rand_particle_pop(50, [0, 0], [1 0; 0 1])\nfirst(population, 3)","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"3-element Vector{Particle}:\n Particle([0.4040308336567521, -1.0956708260389603], [0.0, 0.0], Inf, [0.4040308336567521, -1.0956708260389603], Inf)\n Particle([-0.5690754175927688, -1.9016076908148127], [0.0, 0.0], Inf, [-0.5690754175927688, -1.9016076908148127], Inf)\n Particle([0.9895469924697422, -1.2022337920748436], [0.0, 0.0], Inf, [0.9895469924697422, -1.2022337920748436], Inf)","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"We can use the Logbook to save information about each iteration of the run. Let's save the average, median and best fitness:","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"statnames = [\"avg_fit\", \"median_fit\", \"best_fit\"]\ncallables = [mean, median, minimum]\n\nthedict = LittleDict(statnames, callables)\nlogbook = Logbook(thedict)","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"Logbook(LittleDict{AbstractString, Function, Vector{AbstractString}, Vector{Function}}(\"avg_fit\" => Statistics.mean, \"median_fit\" => Statistics.median, \"best_fit\" => minimum), NamedTuple{(:avg_fit, :median_fit, :best_fit)}[])","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"Now we can use the built-in PSO algorithm:","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"@doc PSO","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"PSO(f::Function, population::Vector{Particle}, k_max::Integer; w=1, c1=1, c2=1)\nPSO(logger::Logbook, f::Function, population::Vector{Particle}, k_max::Integer; w=1, c1=1, c2=1)","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"Argumentsf::Function: Objective function to minimise\npopulation: Population—a list of Particle individuals\nk_max: maximum iterations\nw: Inertia weight. Optional, by default 1.\nc1: Cognitive coefficient (my position). Optional, by default 1\nc2: Social coefficient (swarm position). Optional, by default 1Returns a Result.","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"Let's use the default parameters, and 30 iterations:","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"results = PSO(logbook, michalewicz, population, 30);","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"The output was suppressed so that we can analyse each part of the result separately using the Result functions:","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"@show optimum(results)\n@show optimizer(results)\n@show iterations(results)\n@show f_calls(results)","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"optimum(results) = -1.7987560672102798\noptimizer(results) = [2.1935299266534836, 1.5760612400982805]\niterations(results) = 30\nf_calls(results) = 1550","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"We can also take a look at the logbook's records and see how the calculated statistics changed throughout the run:","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"for (i, I) in enumerate(logbook.records)\n    print(\"it: $(i) with best_pos: $(I[3]) and avg_pos: $(I[1]) \\n\")\nend","category":"page"},{"location":"tuto/pso_michalewicz.html","page":"PSO for continuous optimisation","title":"PSO for continuous optimisation","text":"it: 1 with best_pos: -0.7504688680623768 and avg_pos: 0.027014191784156233 \nit: 2 with best_pos: -0.7906765701486448 and avg_pos: -0.11592097787713364 \nit: 3 with best_pos: -0.8012991501612791 and avg_pos: -0.17770241942233952 \nit: 4 with best_pos: -0.7963864986732629 and avg_pos: -0.17023969225290894 \nit: 5 with best_pos: -0.8726099514277835 and avg_pos: -0.2928504362404555 \nit: 6 with best_pos: -1.1697700406204043 and avg_pos: -0.33670799217170105 \nit: 7 with best_pos: -1.6221334762010642 and avg_pos: -0.3834145274427395 \nit: 8 with best_pos: -0.9285497521300503 and avg_pos: -0.37119067568197167 \nit: 9 with best_pos: -1.7520089205738312 and avg_pos: -0.42151516296756136 \nit: 10 with best_pos: -1.587048845608525 and avg_pos: -0.3869242929292781 \n...\nit: 27 with best_pos: -1.7971172748131834 and avg_pos: -0.4865895651379651 \nit: 28 with best_pos: -1.787184774482611 and avg_pos: -0.4625727297276257 \nit: 29 with best_pos: -1.7916306274124452 and avg_pos: -0.42381102968626794 \nit: 30 with best_pos: -1.77202650821346 and avg_pos: -0.46380678949496384 ","category":"page"},{"location":"man/extending.html#Extending-EvoLP","page":"Custom operators","title":"Extending EvoLP","text":"","category":"section"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"EvoLP was designed with extensibility in mind, by using Julia's dynamic dispatch ability to keep things simple.","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"We have 3 main functions (select, cross and mutate) which will perform differently depending on the parameters passed. By passing a specific type, we ensure that the selection/recombination/mutation acts how we expect to. The available type hierarchy in EvoLP.jl looks like the following:","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"(Image: Block hierarchy)","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"In the image above, the abstract types are highlighted in bold font. The composite types (those you can instantiate) are marked with dotted lines, and those with parameters are bounded in a grey box.","category":"page"},{"location":"man/extending.html#Creating-your-own-blocks","page":"Custom operators","title":"Creating your own blocks","text":"","category":"section"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"If you want to experiment with new building blocks, you can create your own by using the abstract block types as a supertype of your own selectors, mutators and recombinators. These abstract blocks are the following:","category":"page"},{"location":"man/extending.html#EvoLP.BinaryMutator","page":"Custom operators","title":"EvoLP.BinaryMutator","text":"Abstract Mutator for binary individuals.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.ContinuousMutator","page":"Custom operators","title":"EvoLP.ContinuousMutator","text":"Abstract Mutator for real-valued individuals.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.ContinuousRecombinator","page":"Custom operators","title":"EvoLP.ContinuousRecombinator","text":"Abstract continuous recombinator.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.DemeSelector","page":"Custom operators","title":"EvoLP.DemeSelector","text":"Abstract Deme Selector\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.Mutator","page":"Custom operators","title":"EvoLP.Mutator","text":"Abstract Mutation Method.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.NumericRecombinator","page":"Custom operators","title":"EvoLP.NumericRecombinator","text":"Abstract numeric recombinator.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.ParentSelector","page":"Custom operators","title":"EvoLP.ParentSelector","text":"Abstract Parent Selector\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.PermutationMutator","page":"Custom operators","title":"EvoLP.PermutationMutator","text":"Abstract Mutator for permutation individuals.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.PermutationRecombinator","page":"Custom operators","title":"EvoLP.PermutationRecombinator","text":"Abstract permutation recombinator.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.Recombinator","page":"Custom operators","title":"EvoLP.Recombinator","text":"Abstract recombinator.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html#EvoLP.Selector","page":"Custom operators","title":"EvoLP.Selector","text":"Abstract Selector for either Parent or Deme selection methods.\n\n\n\n\n\n","category":"type"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"The abstract types are not exported in EvoLP, which means that you will not see them if you used using EvoLP in your code. You need to access them directly, by writing EvoLP.<theabstractblock>.","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"Once you have your own type, you need to explicitly code how the block should operate. This is done by creating a new method of the select, cross or mutate functions, depending on what your abstract supertype is.","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"After that, you can use the new blocks in your algorithms like any of the other built-in blocks.","category":"page"},{"location":"man/extending.html#A-hypothetical-example","page":"Custom operators","title":"A hypothetical example","text":"","category":"section"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"You can use the corresponding AbstractType to create a new mutation method called MyCrazyMutation. This new mutator would work on a real-valued vector, so it should be a sub-type of the ContinuousMutator abstract type:","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"struct MyCrazyMutation <: EvoLP.ContinuousMutator\n    param1\n    param2\n    param3\nend","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"Then, we can code a new method for the mutate function, which will look something like the following:","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"function mutate(M::MyCrazyMutation, ind; rng=Random.GLOBAL_RNG)\n    mutant = deepcopy(ind)\n    if rand(rng) < param3\n        mutant[1] = mutant[1] + M.param1\n        mutant[2] = mutant[2] - M.param2\n    end\n\n    return mutant\nend","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"This MyCrazyMutation method will then operate on a hypothetical 2-dimensional individual ind, and will change its first dimension by its param1, and the second dimension using param2 if a random number is less than its param3.","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"Then, you can use it in your algorithms as if it was any other block. Here is a fake snippet for illustration purposes:","category":"page"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"function myalgorithm(...)\n    M = MyCrazyMutation(p1, p2, p3)\n    ...\n    mutate(M, ind)\n    ...\nend","category":"page"},{"location":"man/extending.html#A-word-about-randomisation","page":"Custom operators","title":"A word about randomisation","text":"","category":"section"},{"location":"man/extending.html","page":"Custom operators","title":"Custom operators","text":"If using random numbers (for example in crossover or mutation operators) it is always a good idea to pass to your function a random number generator instance. In this way, your code can be used both for unit testing as well as for constructing shareable examples that are reproducible for the sake of science.","category":"page"},{"location":"lib/types.html#Types-in-EvoLP","page":"Types","title":"Types in EvoLP","text":"","category":"section"},{"location":"lib/types.html","page":"Types","title":"Types","text":"Modules = [EvoLP]\nOrder = [:type]","category":"page"},{"location":"man/generators.html#Population-Generators","page":"Population generators","title":"Population Generators","text":"","category":"section"},{"location":"man/generators.html","page":"Population generators","title":"Population generators","text":"To initialise the population, a number of random generators are provided.","category":"page"},{"location":"man/generators.html#Vector-based-populations","page":"Population generators","title":"Vector-based populations","text":"","category":"section"},{"location":"man/generators.html","page":"Population generators","title":"Population generators","text":"For EAs and GAs.","category":"page"},{"location":"man/generators.html#Discrete-domains","page":"Population generators","title":"Discrete domains","text":"","category":"section"},{"location":"man/generators.html#EvoLP.binary_vector_pop","page":"Population generators","title":"EvoLP.binary_vector_pop","text":"binary_vector_pop(n, l; rng=Random.GLOBAL_RNG)\n\nGenerate a population of n vector binary individuals, each of length l.\n\nExamples\n\njulia> using EvoLP\n\njulia> binary_vector_pop(2, 5)\n2-element Vector{BitVector}:\n [1, 0, 1, 1, 0]\n [0, 1, 0, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"man/generators.html#EvoLP.permutation_vector_pop","page":"Population generators","title":"EvoLP.permutation_vector_pop","text":"permutation_vector_pop(n, d, pool; replacement=false, rng=Random.GLOBAL_RNG)\n\nGenerate a population of n permutation vector individuals, of size d and with values sampled from pool. Usually d would be equal to length(pool).\n\nSampling is without replacement by default (generating permutations if pool is a set). When replacement=true then it generates combinations of (possibly) repeated values.\n\nExamples\n\njulia> permutation_vector_pop(1, 8, 1:8)\n1-element Vector{Vector{Int64}}:\n [7, 3, 8, 1, 5, 6, 4, 2]\n\njulia> permutation_vector_pop(2, 5, [\"a\", \"b\", \"c\", \"d\", \"e\"]; replacement=false)\n2-element Vector{Vector{String}}:\n [\"e\", \"b\", \"c\", \"d\", \"a\"]\n [\"b\", \"d\", \"a\", \"e\", \"c\"]\n\n\n\n\n\n","category":"function"},{"location":"man/generators.html#Continuous-domains","page":"Population generators","title":"Continuous domains","text":"","category":"section"},{"location":"man/generators.html#EvoLP.normal_rand_vector_pop","page":"Population generators","title":"EvoLP.normal_rand_vector_pop","text":"normal_rand_vector_pop(n, μ, Σ; rng=Random.GLOBAL_RNG)\n\nGenerate a population of n vector individuals using a normal distribution with means μ and covariance Σ.\n\nμ expects a vector of length l (i.e. length of an individual) while Σ expects an l x l matrix of covariances.\n\nExamples\n\njulia> normal_rand_vector_pop(3, [0, 0], [1 0; 0 1])\n3-element Vector{Vector{Float64}}:\n [-0.15290525182234904, 0.8715880371871617]\n [-1.1283800329864322, -0.9256584563613383]\n [-0.5384758126777555, -0.8141702145510666]\n\n\n\n\n\n","category":"function"},{"location":"man/generators.html#EvoLP.unif_rand_vector_pop","page":"Population generators","title":"EvoLP.unif_rand_vector_pop","text":"unif_rand_vector_pop(n, lb, ub; rng=Random.GLOBAL_RNG)\n\nGenerate a population of n vector individuals using a uniformly random distribution between lower bounds lb and upper bounds ub.\n\nBoth lb and ub must be arrays of the same dimensions.\n\nExamples\n\njulia> unif_rand_vector_pop(3, [-1, -1], [1, 1])\n3-element Vector{Vector{Float64}}:\n [-0.16338687344459046, 0.31576097298524064]\n [-0.941510876597899, 0.8219576462978224]\n [-0.377090051761797, -0.28434454028992096]\n\n\n\n\n\n","category":"function"},{"location":"man/generators.html#Particle-based-populations","page":"Population generators","title":"Particle-based populations","text":"","category":"section"},{"location":"man/generators.html","page":"Population generators","title":"Population generators","text":"For particle-swarm optimisation.","category":"page"},{"location":"man/generators.html","page":"Population generators","title":"Population generators","text":"compat: EvoLP 1.1\nParticle objects in EvoLP pre-v.1.1 had no fitness placeholders. If you use a custom Particle generator, you might want to update it. For built-in generators and algorithms, the update would not be noticeable.","category":"page"},{"location":"man/generators.html#EvoLP.Particle","page":"Population generators","title":"EvoLP.Particle","text":"A single particle in the swarm, with a position x, a velocity v, the best position it has encountered x_best and its evaluations y and y_best\n\n\n\n\n\n","category":"type"},{"location":"man/generators.html#EvoLP.unif_rand_particle_pop","page":"Population generators","title":"EvoLP.unif_rand_particle_pop","text":"unif_rand_particle_pop(n, lb, ub; rng=Random.GLOBAL_RNG)\n\nGenerate a population of n Particle individuals using a uniformly random distribution between lower bounds lb and upper bounds ub.\n\nBoth lb and ub must be arrays of the same dimensions.\n\nExamples\n\njulia> unif_rand_particle_pop(3, [-1, -1], [1, 1])\n3-element Vector{Particle}:\n Particle([1.0823301388655755, 0.1544036055233653], [0, 0], Inf, [1.0823301388655755, 0.1544036055233653], Inf)\n Particle([1.0718059584439532, 1.5793257162200343], [0, 0], Inf, [1.0718059584439532, 1.5793257162200343], Inf)\n Particle([1.732268523018161, 0.32172551959160556], [0, 0], Inf, [1.732268523018161, 0.32172551959160556], Inf)\n\n\n\n\n\n","category":"function"},{"location":"man/generators.html#EvoLP.normal_rand_particle_pop","page":"Population generators","title":"EvoLP.normal_rand_particle_pop","text":"normal_rand_particle_pop(n, μ, Σ; y=Inf, rng=Random.GLOBAL_RNG)\n\nGenerate a population of n Particle using a normal distribution with means μand covarianceΣ`.\n\nμ expects a vector of length l (i.e. number of dimensions) while Σ expects an l x l matrix of covariances.\n\ny is the evaluation and current best value. y is set to Inf by default.\n\nExamples\n\njulia> normal_rand_particle_pop(3, [0, 0], [1 0; 0 1])\n3-element Vector{Particle}:\n Particle([-0.6025996585348097, -1.0055548956861133], [0.0, 0.0], Inf, [-0.6025996585348097, -1.0055548956861133], Inf)\n Particle([-0.7562454555135321, 1.9490439959687778], [0.0, 0.0], Inf, [-0.7562454555135321, 1.9490439959687778], Inf)\n Particle([0.5687241357408321, -0.7406267072113427], [0.0, 0.0], Inf, [0.5687241357408321, -0.7406267072113427], Inf)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions.html#Functions-in-EvoLP","page":"Functions","title":"Functions in EvoLP","text":"","category":"section"},{"location":"lib/functions.html","page":"Functions","title":"Functions","text":"Modules = [EvoLP]\nOrder = [:function]","category":"page"},{"location":"man/cross.html#Crossover-operators","page":"Crossover operators","title":"Crossover operators","text":"","category":"section"},{"location":"man/cross.html","page":"Crossover operators","title":"Crossover operators","text":"Crossover operators (a.k.a. recombinators) in EvoLP work on two parents a and b to generate 1 offspring. All operators are derived from the EvoLP.Recombinator abstract type, and some of them have parameters to control how the recombination is performed. Crossover methods are independent of the data contained in an individual, and are instead dependent on its representation.","category":"page"},{"location":"man/cross.html","page":"Crossover operators","title":"Crossover operators","text":"Currently, crossover is only implemented for vector individuals.","category":"page"},{"location":"man/cross.html#Selecting-a-crossover-operator","page":"Crossover operators","title":"Selecting a crossover operator","text":"","category":"section"},{"location":"man/cross.html","page":"Crossover operators","title":"Crossover operators","text":"warning: Deprecated from EvoLP 1.4\nAll crossover operators have been renamed to recombinators since EvoLP 1.4. The old names will be deprecated in a future major release. Be sure to check the new type ontology.","category":"page"},{"location":"man/cross.html","page":"Crossover operators","title":"Crossover operators","text":"EvoLP provides many built-in recombinators.","category":"page"},{"location":"man/cross.html#Representation-independent","page":"Crossover operators","title":"Representation-independent","text":"","category":"section"},{"location":"man/cross.html","page":"Crossover operators","title":"Crossover operators","text":"Single point, two point and uniform crossover operators work on vectors of any numeric type (binary or continuous representations). Using them on permutation-based vectors could generate unfeasible solutions.","category":"page"},{"location":"man/cross.html#EvoLP.SinglePointRecombinator","page":"Crossover operators","title":"EvoLP.SinglePointRecombinator","text":"Single point crossover.\n\n\n\n\n\n","category":"type"},{"location":"man/cross.html#EvoLP.TwoPointRecombinator","page":"Crossover operators","title":"EvoLP.TwoPointRecombinator","text":"Two point crossover.\n\n\n\n\n\n","category":"type"},{"location":"man/cross.html#EvoLP.UniformRecombinator","page":"Crossover operators","title":"EvoLP.UniformRecombinator","text":"Uniform crossover.\n\n\n\n\n\n","category":"type"},{"location":"man/cross.html#For-continuous-domains","page":"Crossover operators","title":"For continuous domains","text":"","category":"section"},{"location":"man/cross.html#EvoLP.InterpolationRecombinator","page":"Crossover operators","title":"EvoLP.InterpolationRecombinator","text":"Interpolation crossover with scaling parameter λ.\n\n\n\n\n\n","category":"type"},{"location":"man/cross.html#For-permutation-representations","page":"Crossover operators","title":"For permutation representations","text":"","category":"section"},{"location":"man/cross.html","page":"Crossover operators","title":"Crossover operators","text":"Order One (OX1) allows for feasibility to be preserved after recombination.","category":"page"},{"location":"man/cross.html#EvoLP.OX1Recombinator","page":"Crossover operators","title":"EvoLP.OX1Recombinator","text":"Order 1 crossover (OX1) for permutation-based individuals.\n\n\n\n\n\n","category":"type"},{"location":"man/cross.html#Performing-the-crossover","page":"Crossover operators","title":"Performing the crossover","text":"","category":"section"},{"location":"man/cross.html","page":"Crossover operators","title":"Crossover operators","text":"After \"instantiating\" a recombinator, you can use the cross function. cross operates on two parents a and b to generate a new candidate solution. All operators return a new individual, and in the process no individual is modified.","category":"page"},{"location":"man/cross.html#EvoLP.cross","page":"Crossover operators","title":"EvoLP.cross","text":"cross(::SinglePointRecombinator, a, b)\n\nSingle point crossover between parents a and b, at a random point in the chromosome.\n\n\n\n\n\ncross(::TwoPointRecombinator, a, b)\n\nTwo point crossover between parents a and b, at two random points in the chromosome.\n\n\n\n\n\ncrossover(::UniformRecombinator, a, b)\n\nUniform crossover between parents a and b. Each gene of the chromosome is randomly selected from one of the parents.\n\n\n\n\n\ncross(C::InterpolationRecombinator, a, b)\n\nLinear Interpolation crossover between parents a and b. The resulting individual is the addition of a scaled version of each of the parents, using C.λ as a control parameter.\n\n\n\n\n\ncross(::OX1Recombinator, a, b)\n\nOrder 1 crossover between permutation parents a and b. A substring from a is copied directly to the offspring, and the remaining values are copied in the order they appear in b.\n\n\n\n\n\n","category":"function"},{"location":"man/cross.html","page":"Crossover operators","title":"Crossover operators","text":"To obtain a second individual during crossover, use the cross method swapping the arguments.","category":"page"},{"location":"man/selection.html#Selection-operators","page":"Selection operators","title":"Selection operators","text":"","category":"section"},{"location":"man/selection.html","page":"Selection operators","title":"Selection operators","text":"Parent selection operators (a.k.a. selectors) in EvoLP are based on fitness and are used to select individuals for crossover. The selectors always return indices so that individuals can be selected from the population later.","category":"page"},{"location":"man/selection.html","page":"Selection operators","title":"Selection operators","text":"All of these methods perform a single operation, as in a  steady-state algorithm. Each selector returns two parent indices.","category":"page"},{"location":"man/selection.html","page":"Selection operators","title":"Selection operators","text":"For generational algorithms, you need to repeat the selection n times; once per each individual in the population.","category":"page"},{"location":"man/selection.html","page":"Selection operators","title":"Selection operators","text":"All operators are derived from the EvoLP.ParentSelector abstract type, which is itself derived from the EvoLP.Selector abstract super type. Some of the selectors have parameters you can adjust.","category":"page"},{"location":"man/selection.html#Choosing-a-selection-operator","page":"Selection operators","title":"Choosing a selection operator","text":"","category":"section"},{"location":"man/selection.html","page":"Selection operators","title":"Selection operators","text":"warning: Deprecated from EvoLP 1.4\nAll selection operators have been renamed to selectors since EvoLP 1.4. The old names will be deprecated in a future major release. Be sure to check the new type ontology.","category":"page"},{"location":"man/selection.html","page":"Selection operators","title":"Selection operators","text":"EvoLP provides many built-in selectors.","category":"page"},{"location":"man/selection.html#EvoLP.TournamentSelector","page":"Selection operators","title":"EvoLP.TournamentSelector","text":"Tournament parent selection with tournament size T.\n\n\n\n\n\n","category":"type"},{"location":"man/selection.html#EvoLP.TruncationSelector","page":"Selection operators","title":"EvoLP.TruncationSelector","text":"Truncation selection for selecting top k possible parents in the population.\n\n\n\n\n\n","category":"type"},{"location":"man/selection.html#EvoLP.RouletteWheelSelector","page":"Selection operators","title":"EvoLP.RouletteWheelSelector","text":"Roulette wheel parent selection.\n\n\n\n\n\n","category":"type"},{"location":"man/selection.html#EvoLP.RankBasedSelector","page":"Selection operators","title":"EvoLP.RankBasedSelector","text":"Rank-based parent selection.\n\n\n\n\n\n","category":"type"},{"location":"man/selection.html#Performing-the-selection","page":"Selection operators","title":"Performing the selection","text":"","category":"section"},{"location":"man/selection.html","page":"Selection operators","title":"Selection operators","text":"After \"instantiating\" a selection method, you can use the select function on an array of fitnesses y to obtain 2 parents' indices (that you will need to slice from the population in your algorithm later.)","category":"page"},{"location":"man/selection.html#EvoLP.select","page":"Selection operators","title":"EvoLP.select","text":"select(t::TournamentSelector, y)\n\nSelect two parents which are the winners from two random tournaments of size t.T.\n\n\n\n\n\nselect(t::TruncationSelector, y)\n\nSelect two random parents out from the top t.k in the population.\n\n\n\n\n\nselect(::RouletteWheelSelector, y)\n\nSelect two random parents with probability proportional to their fitness.\n\n\n\n\n\nselect(::RankBasedSelector, y)\n\nSelect two random parents with probability proportional to their ranks.\n\n\n\n\n\nselect(S_M::RandomDemeSelector, y)\n\nReturn a list of size S_M.k of random indices from a vector of fitnesses y. Used inside drift to select individuals to be sent to another island, or inside reinsert! to select individuals to be replaced.\n\n\n\n\n\nselect(S_M::WorstDemeSelector, y)\n\nReturn the indices of the S_M.k-worst fitnesses in y. Used inside drift to select individuals to be sent to another island, or inside reinsert! to select individuals to be replaced.\n\n\n\n\n\n","category":"function"},{"location":"man/algorithms.html#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithms.html","page":"Algorithms","title":"Algorithms","text":"EvoLP provides some basic built-in algorithms to get you started. All algorithms are built for minimisation.","category":"page"},{"location":"man/algorithms.html#Evolutionary-Algorithms-(EA)","page":"Algorithms","title":"Evolutionary Algorithms (EA)","text":"","category":"section"},{"location":"man/algorithms.html","page":"Algorithms","title":"Algorithms","text":"The basic 1+1 EA starts with a vector individual and slowly finds its way to an optimum by only using mutation.","category":"page"},{"location":"man/algorithms.html#EvoLP.oneplusone","page":"Algorithms","title":"EvoLP.oneplusone","text":"oneplusone(f, ind, k_max, M)\noneplusone(logger::Logbook, f, ind, k_max, M)\n\n1+1 Evolutionary Algorithm.\n\nArguments\n\nf::Function: objective function to minimise.\nind::AbstractVector: individual to start the evolution.\nk_max::Integer: number of iterations.\nM::Mutator: one of the available Mutator.\n\nReturns a Result.\n\n\n\n\n\n","category":"function"},{"location":"man/algorithms.html#Genetic-Algorithms-(GA)","page":"Algorithms","title":"Genetic Algorithms (GA)","text":"","category":"section"},{"location":"man/algorithms.html","page":"Algorithms","title":"Algorithms","text":"In a GA a population of vector solutions is simulated, where individuals get selected, recombined, and mutated. The built-in implementation in EvoLP is a generational GA taken from Kochenderfer, M.J. and Wheeler, T.A. 2019, which means the whole population is replaced by its offspring at every iteration.","category":"page"},{"location":"man/algorithms.html#EvoLP.GA","page":"Algorithms","title":"EvoLP.GA","text":"GA(f, pop, k_max, S, C, M)\nGA(logbook::Logbook, f, population, k_max, S, C, M)\nGA(notebooks::Vector{Logbook}, f, population, k_max, S, C, M)\n\nGenerational Genetic Algorithm.\n\nArguments\n\nf::Function: objective function to minimise.\npopulation::AbstractVector: a list of vector individuals.\nk_max::Integer: number of iterations.\nS::ParentSelector: one of the available ParentSelector.\nC::Recombinator: one of the available Recombinator.\nM::Mutator: one of the available Mutator.\n\nReturns a Result.\n\n\n\n\n\n","category":"function"},{"location":"man/algorithms.html#Particle-Swarm-Optimisation-(PSO)","page":"Algorithms","title":"Particle Swarm Optimisation (PSO)","text":"","category":"section"},{"location":"man/algorithms.html","page":"Algorithms","title":"Algorithms","text":"In PSO, individuals are particles with velocity and memory. At each iteration, a particle changes its velocity considering the neighbouring particles as well as the best position of the whole swarm.","category":"page"},{"location":"man/algorithms.html","page":"Algorithms","title":"Algorithms","text":"The built-in implementation in EvoLP is taken from Kochenderfer, M.J. and Wheeler, T.A. 2019.","category":"page"},{"location":"man/algorithms.html#EvoLP.PSO","page":"Algorithms","title":"EvoLP.PSO","text":"PSO(f, population, k_max; w=1, c1=1, c2=1)\nPSO(logger::Logbook, f, population, k_max; w=1, c1=1, c2=1)\n\nArguments\n\nf::Function: Objective function to minimise.\npopulation::Vector{Particle}: a list of Particle individuals.\nk_max::Integer: number of iterations.\n\nKeywords\n\nw: inertia weight. Optional, by default 1.\nc1: cognitive coefficient (own's position). Optional, by default 1.\nc2: social coefficient (others' position). Optional, by default 1.\n\nReturns a Result.\n\n\n\n\n\n","category":"function"},{"location":"man/logbook.html#Statistics-Logbook","page":"Logging statistics","title":"Statistics Logbook","text":"","category":"section"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"EvoLP includes a Logbook type which can be used to log statistics during runs.","category":"page"},{"location":"man/logbook.html#EvoLP.Logbook","page":"Logging statistics","title":"EvoLP.Logbook","text":"Logbook()\nLogbook(S::LittleDict)\n\nA log for statistics intended for use on every iteration of an algorithm. The logbook is constructed from a LittleDict ordered dictionary which maps stat names (strings) to callables, such that statname i can be computed from callable i.\n\nThe resulting Logbook contains:\n\nS::LittleDict: The ordered dict of stat names and callables\nrecords::AbstractVector: A vector of NamedTuples where each field is a statistic.\n\nIf no argument is passed, the logbook is constructed with a set of commonly statistics such as minimum, mean, median, maximum and standard deviation; in that order.\n\n\n\n\n\n","category":"type"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"The Logbook receives an OrderedCollections.jl LittleDict (ordered dictionary for a small number of items) with the following format:","category":"page"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"LittleDict(\"statname\"::String => callable::Function)","category":"page"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"For example, using some of the Statistics built-in functions:","category":"page"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"julia> statnames = [\"mean_eval\", \"max_f\", \"min_f\", \"median_f\"];\n\njulia> fns = [mean, maximum, minimum, median];\n\njulia> thedict = LittleDict(statnames, fns)\nLittleDict{String, Function, Vector{String}, Vector{Function}} with 4 entries:\n  \"mean_eval\" => mean\n  \"max_f\"     => maximum\n  \"min_f\"     => minimum\n  \"median_f\"  => median","category":"page"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"Then the logbook can be constructed:","category":"page"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"julia> thelogger = Logbook(thedict)\nLogbook(LittleDict{AbstractString, Function, Vector{AbstractString}, Vector{Function}}(\"mean_eval\" => Statistics.mean, \"max_f\" => maximum, \"min_f\" => minimum, \"median_f\" => Statistics.median), NamedTuple{(:mean_eval, :max_f, :min_f, :median_f)}[])","category":"page"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"If no LittleDict is provided, then the logbook includes a default set of descriptive statistics: minimum, mean, median, maximum and standard deviation&mdash;in that order.","category":"page"},{"location":"man/logbook.html#Computing-statistics","page":"Logging statistics","title":"Computing statistics","text":"","category":"section"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"After instantiating the Logbook, you can use the compute! function on each iteration of an algorithm. The statistics are stored in the records field inside the Logbook, which is a vector of records (NamedTuples). This makes it easier to export as a DataFrame.","category":"page"},{"location":"man/logbook.html#EvoLP.compute!","page":"Logging statistics","title":"EvoLP.compute!","text":"compute!(logger::Logbook, data::AbstractVector)\ncompute!(notebooks::Vector{Logbook}, data::Vector{AbstractVector})\n\nComputes statistics for logger (or a vector of loggers) using data, which is usually a vector of fitnesses. All calculations are done in place, so the logger records will be updated.\n\n\n\n\n\n","category":"function"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"The compute! function can be called either by providing a logbook to update, or a vector of Logbooks. This is useful if that which you want to calculate depends on different data sources (e.g. some statistics are computed from fitness while some others use the population, etc.)","category":"page"},{"location":"man/logbook.html#Statistics-at-a-glance","page":"Logging statistics","title":"Statistics at a glance","text":"","category":"section"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"If you prefer to have a quick overview of your Logbook, you can do so using the summarise function:","category":"page"},{"location":"man/logbook.html#EvoLP.summarise","page":"Logging statistics","title":"EvoLP.summarise","text":"summarise(logger::Logbook)\nsummarise(notebooks::Logbook)\n\nPrint and plot descriptive statistics for a given logger (or a vector of loggers).\n\n\n\n\n\n","category":"function"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":"summarise will go through each of the statistics and present a summary and a Unicode plot:","category":"page"},{"location":"man/logbook.html","page":"Logging statistics","title":"Logging statistics","text":" mean_f \nmax: -0.5333333333333333 \navg: -5.6193333333333335\nmedian: -5.716666666666667 \nmin: -7.366666666666666\nstd: 1.0150625419575374\n             ┌────────────────────────────────────────┐ \n           0 │▖                                       │ \n             │▐                                       │ \n             │▗                                       │ \n             │▐                                       │ \n             │ ▌                                      │ \n             │ ▌                                      │ \n             │ ▐▖                                     │ \n   mean_f    │  ▌                              ▐      │ \n             │  ▌         ▐  ▖                ▖▞▖     │ \n             │  ▐▄▖   ▗  ▖▐▌▖▙▐    █▌    ▗▖   █▌▌ ▖▗▚ │ \n             │  ▐▜█▗▖▙▛▟▐▜▘▙▜▐▐▖ █▌▌▚ ▖▗▗▌█ ▖▗█▌▌▐▙▐▐ │ \n             │   ▐▌███ █▌  █▝ ▘▙▟▝█▘▐▐▜▌▛▌██▀█▌▌▐▐▘▀ ▙│ \n             │   ▝▌▝▛█ ▝▘  ▜    ▘ ▐ ▝▌ ▘  ▘▜ ▀▘  ▀   █│ \n             │       ▐     ▐      ▝                   │ \n          -8 │                                        │ \n             └────────────────────────────────────────┘ \n              0                                    100  \n                                 it                     ","category":"page"},{"location":"index.html#EvoLP-An-evolutionary-computation-playground","page":"Introduction","title":"EvoLP - An evolutionary computation playground","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Welcome to the documentation for EvoLP!","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: GitHub source) (Image: Julia version) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"index.html#What-is-EvoLP?","page":"Introduction","title":"What is EvoLP?","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"EvoLP is a playground for evolutionary computation in Julia. It provides a set of predefined building blocks that can be coupled together to quickly generate evolutionary computation solvers and compute statistics for a variety of optimisation tasks, including discrete, continuous and combinatorial optimisation.","category":"page"},{"location":"index.html#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Random population generators (vectors and particles)\nParent selection operators\nSeveral crossover and mutation methods\nTest functions for benchmarking\nConvenient result reporting and a statistics logbook","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Combine these blocks to make your own algorithms or use some of the included minimisers: GA, 1+1EA and PSO. Additionally, you can extend EvoLP to create new operators.","category":"page"},{"location":"index.html#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Read the quick start page for information about installation and to get a quick overview.\nBrowse some of the examples to see how to use the built-in algorithms.\nFor a more comprehensive tutorial, read the 8-queens problem where we make an algorithm from scratch.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Alternatively, you can browse the type and functions indices to view all available functionality.","category":"page"},{"location":"index.html#Parallel-evaluation-and-Island-Models","page":"Introduction","title":"Parallel evaluation and Island Models","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"EvoLP provides island support via MPI as an extension. Read more about island models in EvoLP and how to achieve parallel evaluation.","category":"page"},{"location":"index.html#Citing-EvoLP.jl","page":"Introduction","title":"Citing EvoLP.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"If you find EvoLP.jl useful in your work or research, we kindly request that you cite the following conference paper:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"@inproceedings{Sanchez-DiazEvoLP2023a,\n  address = {Bergen, NO},\n  author = {Sánchez-Díaz, Xavier F. C. and Mengshoel, Ole Jakob},\n  booktitle = {Proceedings of the 5th Symposium of the Norwegian AI Society},\n  editor = {Galimullin, Rustam and Touileb, Samia},\n  month = jun,\n  publisher = {CEUR Workshop Proceedings},\n  series = {NAIS 2023: Symposium of the Norwegian AI Society 2023},\n  title = {{EvoLP.jl: A Playground for Evolutionary Computation in Julia}},\n  url = {https://ceur-ws.org/Vol-3431/},\n  year = {2023}\n}","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"You can also cite EvoLPIslands, our MPI Extension, by citing the following conference paper:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"@article{sanchez-DiazEvolutionaryComputationIslands2023,\n  title = {{Evolutionary Computation with Islands: Extending EvoLP.Jl for Parallel Computing}},\n  shorttitle = {{Evolutionary Computation with Islands}},\n  author = {Sánchez-Díaz, Xavier F. C. and Mengshoel, Ole Jakob},\n  year = {2023},\n  month = nov,\n  journal = {Norsk {IKT}-konferanse for forskning og utdanning},\n  number = {1},\n  issn = {1892-0721},\n  copyright = {Copyright (c) 2023 Norsk IKT-konferanse for forskning og utdanning},\n}","category":"page"},{"location":"index.html#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"EvoLP started as a toolbox for internal use by PhD students of NTNU's Open AI Lab, and whose funding is provided by Project no. 311284 by The Research Council of Norway.","category":"page"},{"location":"index.html#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"EvoLP is licensed under the MIT License which makes it free and open source.","category":"page"}]
}
