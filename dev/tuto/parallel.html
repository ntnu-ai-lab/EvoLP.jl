<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel Evaluation in EvoLP.jl · EvoLP</title><meta name="title" content="Parallel Evaluation in EvoLP.jl · EvoLP"/><meta property="og:title" content="Parallel Evaluation in EvoLP.jl · EvoLP"/><meta property="twitter:title" content="Parallel Evaluation in EvoLP.jl · EvoLP"/><meta name="description" content="Documentation for EvoLP."/><meta property="og:description" content="Documentation for EvoLP."/><meta property="twitter:description" content="Documentation for EvoLP."/><meta property="og:url" content="https://ntnu-ai-lab.github.io/EvoLP.jl/stable/tuto/parallel.html"/><meta property="twitter:url" content="https://ntnu-ai-lab.github.io/EvoLP.jl/stable/tuto/parallel.html"/><link rel="canonical" href="https://ntnu-ai-lab.github.io/EvoLP.jl/stable/tuto/parallel.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="EvoLP logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="EvoLP logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../man/quickstart.html">Quick start</a></li><li><a class="tocitem" href="../man/algorithms.html">Algorithms</a></li><li><a class="tocitem" href="../man/selection.html">Selection operators</a></li><li><a class="tocitem" href="../man/cross.html">Crossover operators</a></li><li><a class="tocitem" href="../man/mutation.html">Mutation operators</a></li><li><a class="tocitem" href="../man/generators.html">Population generators</a></li><li><a class="tocitem" href="../man/testfunctions.html">Optimisation test functions</a></li><li><a class="tocitem" href="../man/results.html">Reporting results</a></li><li><a class="tocitem" href="../man/logbook.html">Logging statistics</a></li><li><a class="tocitem" href="../man/extending.html">Custom operators</a></li><li><a class="tocitem" href="../man/islands.html">Island Models</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="oneplusone_onemax.html">The OneMax problem</a></li><li><a class="tocitem" href="8_queens.html">The 8 queens problem</a></li><li><a class="tocitem" href="ga_rosenbrock.html">GA for continuous optimisation</a></li><li><a class="tocitem" href="pso_michalewicz.html">PSO for continuous optimisation</a></li><li class="is-active"><a class="tocitem" href="parallel.html">Parallel Evaluation in EvoLP.jl</a><ul class="internal"><li><a class="tocitem" href="#Threads"><span>Threads</span></a></li><li><a class="tocitem" href="#MPI"><span>MPI</span></a></li><li><a class="tocitem" href="#Further-Reading"><span>Further Reading</span></a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../lib/types.html">Types</a></li><li><a class="tocitem" href="../lib/functions.html">Functions</a></li></ul></li><li><a class="tocitem" href="../references.html">References &amp; related links</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="parallel.html">Parallel Evaluation in EvoLP.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="parallel.html">Parallel Evaluation in EvoLP.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ntnu-ai-lab/EvoLP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ntnu-ai-lab/EvoLP.jl/blob/main/docs/src/tuto/parallel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parallel-Evaluation-in-EvoLP.jl"><a class="docs-heading-anchor" href="#Parallel-Evaluation-in-EvoLP.jl">Parallel Evaluation in EvoLP.jl</a><a id="Parallel-Evaluation-in-EvoLP.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Evaluation-in-EvoLP.jl" title="Permalink"></a></h1><p>Evaluation of multiple solutions in parallel can dramatically reduce computational time. This tutorial will illustrate how to do so with Threads and MPI. However, you might also want to check Julia&#39;s built-in <a href="https://docs.julialang.org/en/v1/manual/distributed-computing/">Distributed</a> module.</p><h2 id="Threads"><a class="docs-heading-anchor" href="#Threads">Threads</a><a id="Threads-1"></a><a class="docs-heading-anchor-permalink" href="#Threads" title="Permalink"></a></h2><p>Julia has built-in <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">multithreaded support</a> via the <code>Base.Threads</code> package.</p><p>First, make sure you are running Julia with several threads.</p><details class="admonition is-details" id="Details-fc34590f815d8375"><summary class="admonition-header">Details<a class="admonition-anchor" href="#Details-fc34590f815d8375" title="Permalink"></a></summary><div class="admonition-body"><p>By using the the <code>-t</code> option, Julia can be started with several threads. For example, <code>julia -t 4</code> will start Julia with 4 threads.</p></div></details><p>Then, you can add the <code>@threads</code> macro to the evaluation loop of your algorithms:</p><pre><code class="language-julia hljs"># generate population
# set selection, crossover and mutation operators
# set fitness function f
N = length(population)
fitnesses = zeros(N)
@threads for i in eachindex(fitnesses)
    fitnesses[i] = f(population[i])
end
# do selection, crossover, mutation...
# repeat</code></pre><p>The scheduler will automatically spawn and sync all available threads to Julia in order to finish the computation. This is the easiest way to do parallel computations with EvoLP, but it is limited to a single physical processor. If you need many more processes/cores, consider using Distributed or MPI.</p><h2 id="MPI"><a class="docs-heading-anchor" href="#MPI">MPI</a><a id="MPI-1"></a><a class="docs-heading-anchor-permalink" href="#MPI" title="Permalink"></a></h2><div class="admonition is-info" id="Note-e0a1c03ef6b78f61"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e0a1c03ef6b78f61" title="Permalink"></a></header><div class="admonition-body"><p>This is a somewhat advanced topic, as you need to specify and handle the communication between processors yourself. However, it can scale very well, up to HPC clusters.</p></div></div><p><a href="https://www.mpi-forum.org/">MPI</a> (short for <em>Message Passing Interface</em>) is a library interface specification that addresses the parallel model in which data moves between computers through messages. It is one of the most widely used standards for parallel programming in High-Performance Computing (HPC) systems, and so it is available on many clusters. Nevertheless, you can run MPI on your local device as well.</p><p>In EvoLP, we use the MPI bindings for Julia included in the <a href="https://juliaparallel.org/MPI.jl/stable/">MPI.jl</a> package. It is important to remark that EvoLP does not load MPI.jl by default. Instead, it is used as an <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions)">extension</a>, so it will be available if you load MPI.jl in your code along with EvoLP.jl.</p><h3 id="Installing-MPI-Locally"><a class="docs-heading-anchor" href="#Installing-MPI-Locally">Installing MPI Locally</a><a id="Installing-MPI-Locally-1"></a><a class="docs-heading-anchor-permalink" href="#Installing-MPI-Locally" title="Permalink"></a></h3><p>For installation and configuration, kindly follow the steps defined in the <a href="https://juliaparallel.org/MPI.jl/stable/configuration/">MPI.jl documentation</a>.</p><p>Nonetheless, you might be able to install it through a package manager. We have tested the <a href="https://www.mpich.org/">MPICH</a> implementation on both Ubuntu 22 (using <code>apt</code>) and Fedora 42 (using <code>dnf</code>).</p><p>In some cases, the MPICH package might get installed as in a SLURM cluster. In such situations, the module needs to be loaded first to see the available executables:</p><pre><code class="language-sh-session hljs">$ module load mpi</code></pre><p>This will allow the <code>mpiexec</code> and <code>mpirun</code> commands&amp;mdash;which are needed to execute Julia scripts in parallel&amp;mdash;to become available in your shell.</p><p>We highly suggest that you try first the <a href="https://juliaparallel.org/MPI.jl/stable/usage/">MPI.jl Basic Example</a>.</p><h3 id="Island-Models-using-MPI"><a class="docs-heading-anchor" href="#Island-Models-using-MPI">Island Models using MPI</a><a id="Island-Models-using-MPI-1"></a><a class="docs-heading-anchor-permalink" href="#Island-Models-using-MPI" title="Permalink"></a></h3><h4 id="Step-1:-Code-your-island"><a class="docs-heading-anchor" href="#Step-1:-Code-your-island">Step 1: Code your island</a><a id="Step-1:-Code-your-island-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Code-your-island" title="Permalink"></a></h4><p>If you have not done so, please read the documentation page on <a href="../man/islands.html">island models</a>.</p><p>Assume you have a very basic island model using the following settings:</p><p>An archipelago with 4 islands, optimising the <a href="../man/testfunctions.html#EvoLP.michalewicz"><code>michalewicz</code></a> function. All islands are identical, and each island features:</p><ul><li>A population <span>$P$</span> of <span>$N=30$</span> 2-dimensional vectors (individuals)<ul><li>where <span>$P \sim \mathcal{U}(\{\boldsymbol{x} | \boldsymbol{x} \in \mathbb{R}^2, x \in [0, \pi]\})$</span></li></ul></li><li>A rank-based selector: <a href="../man/selection.html#EvoLP.RankBasedSelector"><code>RankBasedSelector</code></a></li><li>A uniform crossover operator: <a href="../man/cross.html#EvoLP.UniformRecombinator"><code>UniformRecombinator</code></a></li><li>A Gaussian mutation operator with <span>$\sigma = 0.1$</span>: <a href="../man/mutation.html#EvoLP.GaussianMutator"><code>GaussianMutator</code></a></li></ul><p>The algorithm will run for 100 iterations, and every <span>$\mu=10$</span> iterations, it will send a deme of 10% of the population size, i.e., <span>$k=0.1N$</span> (3 individuals). It will select the <span>$k$</span> individuals at random, and will replace the worst <span>$k$</span> individuals in the new island.</p><p>The migration topology is a ring, so each island will send its deme to the next island:</p><p class="math-container">\[1 \to 2 \to 3 \to 4 \to 1\]</p><p>Then, the code would look similar to this:</p><pre><code class="language-julia hljs">using EvoLP  # Load EvoLP
using OrderedCollections
using MPI  # Load MPI.jl!
using Statistics

MPI.Init()  # Initialize MPI

comm = MPI.COMM_WORLD  # Initialize the MPI communication world
ranks = MPI.Comm_size(comm)  # Create a rank for each island
myrank = MPI.Comm_rank(comm)  # Assign each island to its rank

dest = mod(myrank+1, ranks)  # Set destination (Deme I am sending)
src = mod(myrank-1, ranks)  # Set source (Deme I am receiving)

# GA operators
N = 30
S_P = RankBasedSelector()
X = UniformRecombinator()
Mut = GaussianMutator(0.1)
max_it = 100

# Island operators
k = 0.1*N # deme size
S_M = RandomDemeSelector(k)  # migration selection policy
R_M = WorstDemeSelector(k)  # migration replacement policy
μ = 10  # number of iterations between migration

P = unif_rand_vector_pop(N, [0, 0], [π, π])

thelog = Logbook()

res = islandGA!(thelog, michalewicz, P, max_it, S_P, X, Mut, μ, S_M, R_M, dest, src, comm)

print(&quot;&quot;&quot;Result on run from rank $(myrank) was $(optimum(res)) achieved by $(optimizer(res))\n&quot;&quot;&quot;)</code></pre><p>In this snippet of code, we are using the toy built-in algorithm <a href="../man/islands.html#EvoLP.islandGA!"><code>islandGA!</code></a>.</p><h4 id="Step-2:-Run-your-model"><a class="docs-heading-anchor" href="#Step-2:-Run-your-model">Step 2: Run your model</a><a id="Step-2:-Run-your-model-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Run-your-model" title="Permalink"></a></h4><p>Once the script is finished, you can run it using MPI from the terminal. Assuming our script is called <code>scratch.jl</code>:</p><p>You can run it using <code>mpiexec</code>, as such:</p><pre><code class="language-sh-session hljs">$ mpiexec -n 4 julia --project=./ ./scratch.jl</code></pre><p>Notice we are using <code>-n 4</code> to run 4 islands, but this is where MPI really shines as it can scale very easily.</p><p>The result should look something like this:</p><pre><code class="language-sh-session hljs">$ mpiexec -n 4 julia --project=./ ./scratch.jl
Result on run from rank 0 was -1.7918109629302714 achieved by [2.1799811139347045, 1.5759514028959793]
Result on run from rank 1 was -1.7687392718383559 achieved by [2.2092215285901076, 1.5988409423611978]
Result on run from rank 3 was -1.784211505064787 achieved by [2.213698645080214, 1.5512366106384692]
Result on run from rank 2 was -1.7738196053483932 achieved by [2.2115479736169856, 1.54495573080501]</code></pre><h3 id="Running-on-an-HPC-cluster"><a class="docs-heading-anchor" href="#Running-on-an-HPC-cluster">Running on an HPC cluster</a><a id="Running-on-an-HPC-cluster-1"></a><a class="docs-heading-anchor-permalink" href="#Running-on-an-HPC-cluster" title="Permalink"></a></h3><div class="admonition is-warning" id="Warning-de3ded7542566200"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-de3ded7542566200" title="Permalink"></a></header><div class="admonition-body"><p>Each HPC system is different, so you might need to adapt these instructions. Nevertheless, this is a good starting point.</p></div></div><p>We have tested EvoLP using <a href="https://slurm.schedmd.com/documentation.html">SLURM</a>. Assuming you have a julia module available, then the process is very similar to the steps above. You can submit an bash script similar to this:</p><pre><code class="language-bash hljs">#!/usr/bin/bash
#SBATCH -J julia-mpi-test
#SBATCH -n 64
#SBATCH -c 1

module load foss/2022b
module load Julia/1.9.3-linux-x86_64

srun julia scratch.jl</code></pre><p>Which can then submitted as:</p><pre><code class="language-sh-session hljs">$ sbatch myjuliajob.sh</code></pre><p>Assuming you named your bash script as <code>myjuliajob.sh</code>. Note that the module <code>foss/2022b</code> is one of many modules that include MPI. <code>intel-compilers</code> is another module that normally includes MPI as well. In our script, the <code>srun</code> command will run the <code>scratch.jl</code> julia script that corresponds to an island. Then, it will create <code>-n 64</code> copies of the script, and run them in  the MPI world.</p><p>Again, each HPC system is different, and the modules and tricks available are usually specific to each system. You might have to experiment a bit.</p><h2 id="Further-Reading"><a class="docs-heading-anchor" href="#Further-Reading">Further Reading</a><a id="Further-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Reading" title="Permalink"></a></h2><ul><li><a href="https://docs.julialang.org/en/v1/manual/distributed-computing/">Distributed</a>: Julia&#39;s built-in distributed computing module</li><li>The <a href="https://juliaparallel.org/MPI.jl/stable/">MPI.jl documentation</a>.</li><li>Our paper <a href="https://www.ntnu.no/ojs/index.php/nikt/article/view/5667">Evolutionary Computation with Islands: Extending EvoLP.jl for Parallel Computing</a>.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="pso_michalewicz.html">« PSO for continuous optimisation</a><a class="docs-footer-nextpage" href="../lib/types.html">Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 30 September 2025 14:36">Tuesday 30 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
